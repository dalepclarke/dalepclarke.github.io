{"version":3,"sources":["webpack:///../../../../src/rendering/renderers/gpu/BindGroupSystem.ts","webpack:///../../../../../src/rendering/renderers/gpu/buffer/GpuBufferSystem.ts","webpack:///../../../../../../src/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.ts","webpack:///../../../../src/rendering/renderers/gpu/GpuDeviceSystem.ts","webpack:///../../../../src/scene/mesh/gpu/GpuMeshAdapter.ts","webpack:///../../../../src/rendering/renderers/gpu/GpuUboSystem.ts","webpack:///../../../../../src/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.ts","webpack:///../../../../src/rendering/renderers/gpu/GpuEncoderSystem.ts","webpack:///../../../../../src/rendering/renderers/gpu/shader/GpuShaderSystem.ts","webpack:///../../../../../src/rendering/renderers/gpu/texture/GpuTextureSystem.ts","webpack:///../../../../../../src/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.ts","webpack:///../../../../src/scene/graphics/gpu/GpuGraphicsAdaptor.ts","webpack:///../../../../src/rendering/batcher/gpu/GpuBatchAdaptor.ts","webpack:///../../../../../src/rendering/renderers/gpu/buffer/UboBatch.ts","webpack:///../../../../../src/rendering/renderers/shared/texture/CanvasPool.ts","webpack:///../../../../../src/rendering/renderers/gpu/state/GpuStateSystem.ts","webpack:///../../../../src/rendering/renderers/gpu/GpuUniformBatchPipe.ts","webpack:///../../../../src/rendering/renderers/gpu/GpuColorMaskSystem.ts","webpack:///../../../../../../src/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.ts","webpack:///../../../../src/rendering/renderers/gpu/GpuStencilSystem.ts","webpack:///../../../../../src/rendering/renderers/gpu/state/GpuBlendModesToPixi.ts","webpack:///../../../../../../src/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.ts","webpack:///../../../../../../src/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.ts","webpack:///../../../../../../src/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.ts","webpack:///../../../../../src/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.ts","webpack:///../../../../src/rendering/renderers/gpu/WebGPURenderer.ts","webpack:///../../../../../../src/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.ts","webpack:///../../../../../../src/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.ts","webpack:///../../../../../src/rendering/renderers/gpu/renderTarget/GpuRenderTarget.ts","webpack:///../../../../../src/rendering/renderers/gpu/pipeline/PipelineSystem.ts"],"names":["BindGroupSystem","constructor","renderer","_hash","Object","create","this","_renderer","contextChange","gpu","_gpu","getBindGroup","bindGroup","program","groupIndex","_updateKey","gpuBindGroup","_key","_createBindGroup","group","device","groupLayout","layout","entries","j","_group$resources$j","resource","resources","gpuResource","_resourceType","uniformGroup","ubo","updateUniformGroup","buffer","getGPUBuffer","offset","size","descriptor","bufferResource","sampler","texture","getGpuSampler","getGpuSource","createView","push","binding","shader","getProgramData","bindGroups","createBindGroup","destroy","key","keys","extension","type","ExtensionType","WebGPUSystem","name","GpuBufferSystem","_gpuBuffers","_managedBuffers","uid","createGPUBuffer","updateBuffer","gpuBuffer","data","_updateID","queue","writeBuffer","_updateSize","byteLength","destroyAll","id","on","onBufferChange","onBufferDestroy","createBuffer","fastCopy","getMappedRange","unmap","splice","indexOf","_destroyBuffer","forEach","off","createUboSyncFunctionWGSL","uboElements","createUboSyncFunction","generateArraySyncWGSL","uboSyncFunctionsWGSL","GpuDeviceSystem","options","_initPromise","_createDeviceAndAdaptor","then","runners","emit","adapter","navigator","requestAdapter","powerPreference","forceFallbackAdapter","requiredFeatures","filter","feature","features","has","requestDevice","defaultOptions","GpuMeshAdapter","init","gpuProgram","compileHighShaderGpuProgram","bits","localUniformBit","textureBit","roundPixelsBit","_shader","Shader","uTexture","Texture","EMPTY","_source","uSampler","style","textureUniforms","uTextureMatrix","value","Matrix","execute","meshPipe","mesh","warn","source","uniforms","textureMatrix","mapCoord","autoAssignGlobalUniforms","groups","globalUniforms","autoAssignLocalUniforms","localUniforms","renderPipes","uniformBatch","getUniformBindGroup","encoder","draw","geometry","_geometry","state","WebGPUPipesAdaptor","GpuUboSystem","UboSystem","createUboElements","createUboElementsWGSL","generateUboSync","GpuRenderTargetSystem","RenderTargetSystem","super","adaptor","GpuRenderTargetAdaptor","GpuEncoderSystem","_boundBindGroup","_boundVertexBuffer","renderStart","commandFinished","Promise","resolve","_resolveCommandFinished","commandEncoder","createCommandEncoder","beginRenderPass","gpuRenderTarget","endRenderPass","_clearCache","renderPassEncoder","end","setViewport","viewport","x","y","width","height","setPipelineFromGeometryProgramAndState","topology","pipeline","getPipeline","setPipeline","_boundPipeline","_setVertexBuffer","index","setVertexBuffer","_setIndexBuffer","_boundIndexBuffer","indexFormat","BYTES_PER_ELEMENT","setIndexBuffer","resetBindGroup","setBindGroup","_touch","textureGC","count","setGeometry","i","attributes","attribute","location","indexBuffer","_setShaderBindGroups","skipSync","_syncBindGroup","isUniformGroup","start","instanceCount","drawIndexed","length","getSize","finishRenderPass","postrender","submit","finish","restoreRenderPass","renderTarget","getDescriptor","boundPipeline","boundVertexBuffer","boundIndexBuffer","boundBindGroup","priority","GpuShaderSystem","_gpuProgramData","_layoutKey","_createGPUProgramData","gpuLayout","map","createBindGroupLayout","pipelineLayoutDesc","bindGroupLayouts","createPipelineLayout","GpuTextureSystem","managedTextures","_gpuSources","_gpuSamplers","_bindGroupHash","_textureViewHash","_uploads","image","gpuUploadImageResource","gpuUploadBufferImageResource","video","gpuUploadVideoResource","compressed","gpuUploadCompressedTextureResource","initSource","autoGenerateMipmaps","biggestDimension","Math","max","pixelWidth","pixelHeight","mipLevelCount","floor","log2","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","uploadMethodId","RENDER_ATTACHMENT","COPY_SRC","blockData","blockDataMap","format","blockBytes","blockWidth","blockHeight","ceil","textureDescriptor","label","sampleCount","dimension","gpuTexture","createTexture","includes","onSourceUpdate","onSourceResize","onSourceDestroy","onSourceUnload","onUpdateMipmaps","upload","_mipmapGenerator","GpuMipmapGenerator","generateMipmap","_initSampler","_resourceId","createSampler","getTextureBindGroup","_this$_bindGroupHash$","_createTextureBindGroup","bindGroupId","BindGroup","0","1","getTextureView","_this$_textureViewHas","_createTextureView","generateCanvas","canvas","DOMAdapter","get","createCanvas","context","getContext","configure","getPreferredCanvasFormat","alphaMode","copyTextureToTexture","origin","getCurrentTexture","getPixels","webGPUCanvas","canvasAndContext","CanvasPool","getOptimalCanvasAndContext","drawImage","imageData","getImageData","pixels","Uint8ClampedArray","returnCanvasAndContext","slice","k","Number","min","resourceWidth","resourceHeight","premultipliedAlpha","copyExternalImageToTexture","GpuGraphicsAdaptor","UniformGroup","uTransformMatrix","uColor","Float32Array","uRound","colorBit","generateTextureBatchBit","MAX_TEXTURES","localUniformBitGroup2","graphicsPipe","renderable","customShader","contextSystem","graphicsContext","instructions","getContextRenderData","globalUniformsBindGroup","localBindGroup","batches","instructionSize","batch","textureBatch","textures","getTextureBatchBindGroup","tempState","State","for2d","GpuBatchAdaptor","batchPipe","blendMode","UboBatch","_ref","minUniformOffsetAlignment","_minUniformOffsetAlignment","byteIndex","clear","addEmptyGroup","Error","newSize","addGroup","array","_buffer","CanvasPoolClass","canvasOptions","_canvasPool","enableFullScreen","_createCanvasAndContext","minWidth","minHeight","resolution","arguments","undefined","nextPow2","pop","GpuStateSystem","defaultState","blend","getColorTargets","GpuBlendModesToPixi","normal","writeMask","GpuUniformBatchPipe","_buffers","_bindGroups","_bufferResources","_batchBuffer","totalBuffers","BufferUsage","UNIFORM","Buffer","renderEnd","_uploadBindGroups","_resetBindGroups","duplicate","ensureUniformGroup","syncUniformGroup","_getBindGroup","getUboResource","_getBufferResource","getArrayBindGroup","getArrayBufferResource","BufferResource","bufferSystem","firstBuffer","update","copyBufferToBuffer","WebGPUPipes","GpuColorMaskSystem","_colorMaskCache","setMask","colorMask","setColorMask","defaultBlockData","mipWidth","mipHeight","levelBuffer","bytesPerRow","writeTexture","mipLevel","depthOrArrayLayers","GpuStencilSystem","_renderTargetStencilState","onRenderTargetChange","add","stencilState","stencilMode","STENCIL_MODES","DISABLED","stencilReference","_activeRenderTarget","setStencilMode","setStencilReference","remove","alpha","srcFactor","dstFactor","operation","color","uboElement","offsetToAdd","align","WGSL_ALIGN_SIZE_DATA","remainder","minFilter","pipelines","_getMipmapPipeline","mipmapShaderModule","createShaderModule","code","createRenderPipeline","vertex","module","entryPoint","fragment","targets","mipTexture","arrayLayerCount","renderToSource","mipTextureDescriptor","bindGroupLayout","getBindGroupLayout","arrayLayer","srcView","baseMipLevel","baseArrayLayer","dstMipLevel","dstView","passEncoder","colorAttachments","view","storeOp","loadOp","clearValue","r","g","b","a","mipLevelSize","renderTargetSystem","_renderTargetSystem","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","baseGpuTexture","_getGpuColorTexture","backGpuTexture","startRenderPass","clearColor","getGpuRenderTarget","setRenderTarget","contexts","colorTextures","CLEAR","ALL","NONE","_clearValue","resolveTarget","currentTexture","canvasTextureView","msaaTextures","COLOR","defaultClearColor","depthStencilAttachment","stencil","depth","depthStencilTexture","ensureDepthStencilTexture","msaa","stencilLoadOp","STENCIL","depthLoadOp","DEPTH","stencilStoreOp","depthClearValue","depthStoreOp","standAlone","renderPassDescriptor","gpuCommands","initGpuRenderTarget","isRoot","GpuRenderTarget","colorTexture","CanvasSource","test","transparent","e","console","error","antialias","msaaTexture","TextureSource","msaaSamples","destroyGpuRenderTarget","unconfigure","resizeGpuRenderTarget","resize","_resolution","DefaultWebGPUSystems","SharedSystems","PipelineSystem","DefaultWebGPUPipes","SharedRenderPipes","DefaultWebGPUAdapters","systems","renderPipeAdaptors","extensions","handleByNamedList","WebGPURenderer","AbstractRenderer","systemConfig","RendererType","WEBGPU","total","bytesPerPixel","rowsPerImage","i32","u32","f32","f16","uniformData","topologyStringToId","getGraphicsStateKey","geometryLayout","shaderKey","getGlobalStateKey","stencilStateId","multiSampleCount","_moduleCache","_bufferLayoutsCache","_pipeCache","_pipeStateCaches","_colorMask","_multisampleCount","_updatePipeHash","setMultisampleCount","multisampleCount","_depthStencilAttachment","_stencilMode","_stencilState","GpuStencilModesToPixi","ensureAttributes","attributeData","_generateBufferKey","_blendModeId","_createPipeline","buffers","_createVertexBufferLayouts","blendModes","RENDERING_MASK_ADD","_getModule","primitive","cullMode","multisample","depthStencil","depthWriteEnabled","depthTest","depthCompare","_createModule","keyGen","attributeKeys","sort","stride","stringKey","join","createIdFromString","vertexBuffersLayout","bufferEntry","arrayStride","stepMode","bufferEntryAttributes","instance","shaderLocation"],"mappings":"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","file":"js/chunk-44869a72.b8ee09aa.js","sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { BufferResource } from '../shared/buffer/BufferResource';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { System } from '../shared/system/System';\nimport type { TextureSource } from '../shared/texture/sources/TextureSource';\nimport type { TextureStyle } from '../shared/texture/TextureStyle';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { BindResource } from './shader/BindResource';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the WebGPU bind groups. this is how data is bound to a shader when rendering\n * @memberof rendering\n */\nexport class BindGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'bindGroup',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _hash: Record<string, GPUBindGroup> = Object.create(null);\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getBindGroup(bindGroup: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        bindGroup._updateKey();\n\n        const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n\n        return gpuBindGroup;\n    }\n\n    private _createBindGroup(group: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        const device = this._gpu.device;\n        const groupLayout = program.layout[groupIndex];\n        const entries: GPUBindGroupEntry[] = [];\n        const renderer = this._renderer;\n\n        for (const j in groupLayout)\n        {\n            const resource: BindResource = group.resources[j] ?? group.resources[groupLayout[j]];\n            let gpuResource: GPUSampler | GPUTextureView | GPUExternalTexture | GPUBufferBinding;\n            // TODO make this dynamic..\n\n            if (resource._resourceType === 'uniformGroup')\n            {\n                const uniformGroup = resource as UniformGroup;\n\n                renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n\n                const buffer = uniformGroup.buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'buffer')\n            {\n                const buffer = resource as Buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'bufferResource')\n            {\n                const bufferResource = resource as BufferResource;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n                    offset: bufferResource.offset,\n                    size: bufferResource.size,\n                };\n            }\n            else if (resource._resourceType === 'textureSampler')\n            {\n                const sampler = resource as TextureStyle;\n\n                gpuResource = renderer.texture.getGpuSampler(sampler);\n            }\n            else if (resource._resourceType === 'textureSource')\n            {\n                const texture = resource as TextureSource;\n\n                gpuResource = renderer.texture.getGpuSource(texture).createView({\n\n                });\n            }\n\n            entries.push({\n                binding: groupLayout[j],\n                resource: gpuResource,\n            });\n        }\n\n        const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n\n        const gpuBindGroup = device.createBindGroup({\n            layout,\n            entries,\n        });\n\n        this._hash[group._key] = gpuBindGroup;\n\n        return gpuBindGroup;\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._hash))\n        {\n            this._hash[key] = null;\n        }\n\n        this._hash = null;\n\n        (this._renderer as null) = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\n\n/**\n * System plugin to the renderer to manage buffers.\n * @memberof rendering\n */\nexport class GpuBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    protected CONTEXT_UID: number;\n    private _gpuBuffers: { [key: number]: GPUBuffer } = Object.create(null);\n    private readonly _managedBuffers: Buffer[] = [];\n\n    private _gpu: GPU;\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    }\n\n    public updateBuffer(buffer: Buffer): GPUBuffer\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n\n        const data = buffer.data;\n\n        // TODO this can be better...\n        if (buffer._updateID && data)\n        {\n            buffer._updateID = 0;\n\n            // make sure\n            this._gpu.device.queue.writeBuffer(\n                gpuBuffer, 0, data.buffer, 0,\n                // round to the nearest 4 bytes\n                ((buffer._updateSize || data.byteLength) + 3) & ~3\n            );\n        }\n\n        return gpuBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        for (const id in this._gpuBuffers)\n        {\n            this._gpuBuffers[id].destroy();\n        }\n\n        this._gpuBuffers = {};\n    }\n\n    public createGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        if (!this._gpuBuffers[buffer.uid])\n        {\n            buffer.on('update', this.updateBuffer, this);\n            buffer.on('change', this.onBufferChange, this);\n            buffer.on('destroy', this.onBufferDestroy, this);\n        }\n\n        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n\n        buffer._updateID = 0;\n\n        if (buffer.data)\n        {\n            // TODO if data is static, this can be mapped at creation\n            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n\n            gpuBuffer.unmap();\n        }\n\n        this._gpuBuffers[buffer.uid] = gpuBuffer;\n\n        this._managedBuffers.push(buffer);\n\n        return gpuBuffer;\n    }\n\n    protected onBufferChange(buffer: Buffer)\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n        buffer._updateID = 0;\n        this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n    }\n\n    /**\n     * Disposes buffer\n     * @param buffer - buffer with data\n     */\n    protected onBufferDestroy(buffer: Buffer): void\n    {\n        this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n\n        this._destroyBuffer(buffer);\n    }\n\n    public destroy(): void\n    {\n        this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));\n\n        (this._managedBuffers as null) = null;\n\n        this._gpuBuffers = null;\n    }\n\n    private _destroyBuffer(buffer: Buffer): void\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n\n        buffer.off('update', this.updateBuffer, this);\n        buffer.off('change', this.onBufferChange, this);\n        buffer.off('destroy', this.onBufferDestroy, this);\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n}\n\n","/* eslint-disable quote-props */\nimport { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\nexport function createUboSyncFunctionWGSL(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboWgsl',\n        generateArraySyncWGSL,\n        uboSyncFunctionsWGSL,\n    );\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { GpuPowerPreference } from '../types';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/** The GPU object. */\nexport interface GPU\n{\n    /** The GPU adapter */\n    adapter: GPUAdapter;\n    /** The GPU device */\n    device: GPUDevice;\n}\n\n/**\n * Options for the WebGPU context.\n * @property {GpuPowerPreference} [powerPreference=default] - An optional hint indicating what configuration of GPU\n * is suitable for the WebGPU context, can be `'high-performance'` or `'low-power'`.\n * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n * while setting to `'low-power'` will prioritize power saving over rendering performance.\n * @property {boolean} [forceFallbackAdapter=false] - Force the use of the fallback adapter\n * @memberof rendering\n */\nexport interface GpuContextOptions\n{\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @default undefined\n     * @memberof rendering.WebGPUOptions\n     */\n    powerPreference?: GpuPowerPreference;\n    /**\n     * Force the use of the fallback adapter\n     * @default false\n     * @memberof rendering.WebGPUOptions\n     */\n    forceFallbackAdapter: boolean;\n}\n\n/**\n * System plugin to the renderer to manage the context.\n * @class\n * @memberof rendering\n */\nexport class GpuDeviceSystem implements System<GpuContextOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'device',\n    } as const;\n\n    /** The default options for the GpuDeviceSystem. */\n    public static defaultOptions: GpuContextOptions = {\n        /**\n         * {@link WebGPUOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * Force the use of the fallback adapter\n         * @default false\n         */\n        forceFallbackAdapter: false,\n    };\n\n    /** The GPU device */\n    public gpu: GPU;\n\n    private _renderer: WebGPURenderer;\n    private _initPromise: Promise<void>;\n\n    /**\n     * @param {WebGPURenderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public async init(options: GpuContextOptions): Promise<void>\n    {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = this._createDeviceAndAdaptor(options)\n            .then((gpu) =>\n            {\n                this.gpu = gpu;\n\n                this._renderer.runners.contextChange.emit(this.gpu);\n            });\n\n        return this._initPromise;\n    }\n\n    /**\n     * Handle the context change event\n     * @param gpu\n     */\n    protected contextChange(gpu: GPU): void\n    {\n        this._renderer.gpu = gpu;\n    }\n\n    /**\n     * Helper class to create a WebGL Context\n     * @param {object} options - An options object that gets passed in to the canvas element containing the\n     *    context attributes\n     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n     * @returns {WebGLRenderingContext} the WebGL context\n     */\n    private async _createDeviceAndAdaptor(options: GpuContextOptions): Promise<GPU>\n    {\n        // TODO we only need one of these..\n        const adapter = await navigator.gpu.requestAdapter({\n            powerPreference: options.powerPreference,\n            forceFallbackAdapter: options.forceFallbackAdapter,\n        });\n\n        const requiredFeatures = [\n            'texture-compression-bc',\n            'texture-compression-astc',\n            'texture-compression-etc2',\n        ].filter((feature) => adapter.features.has(feature)) as GPUFeatureName[];\n\n        // TODO and one of these!\n        const device = await adapter.requestDevice({\n            requiredFeatures\n        });\n\n        return { adapter, device };\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * The WebGL adaptor for the mesh system. Allows the Mesh System to be used with the WebGl renderer\n * @memberof rendering\n * @ignore\n */\nexport class GpuMeshAdapter implements MeshAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBit,\n                textureBit,\n                roundPixelsBit,\n            ]\n        });\n\n        this._shader = new Shader({\n            gpuProgram,\n            resources: {\n                uTexture: Texture.EMPTY._source,\n                uSampler: Texture.EMPTY._source.style,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh)\n    {\n        const renderer = meshPipe.renderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            shader.resources.uTexture = mesh.texture.source;\n            shader.resources.uSampler = mesh.texture.source.style;\n            shader.resources.textureUniforms.uniforms.uTextureMatrix = mesh.texture.textureMatrix.mapCoord;\n        }\n        else if (!shader.gpuProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no gpuProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        const gpuProgram = shader.gpuProgram;\n        // GPU..\n\n        if (gpuProgram.autoAssignGlobalUniforms)\n        {\n            shader.groups[0] = renderer.globalUniforms.bindGroup;\n        }\n\n        if (gpuProgram.autoAssignLocalUniforms)\n        {\n            const localUniforms = meshPipe.localUniforms;\n\n            shader.groups[1] = (renderer as WebGPURenderer)\n                .renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n        }\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL';\n\n/**\n * System plugin to the renderer to manage uniform buffers. With a WGSL twist!\n * @memberof rendering\n */\nexport class GpuUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsWGSL,\n            generateUboSync: createUboSyncFunctionWGSL,\n        });\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor';\n\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuRenderTarget } from './GpuRenderTarget';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @memberof rendering\n */\nexport class GpuRenderTargetSystem extends RenderTargetSystem<GpuRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GpuRenderTargetAdaptor();\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { GpuRenderTarget } from './renderTarget/GpuRenderTarget';\nimport type { GpuRenderTargetAdaptor } from './renderTarget/GpuRenderTargetAdaptor';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles encoding commands for the GPU.\n * @memberof rendering\n */\nexport class GpuEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'encoder',\n        priority: 1\n    } as const;\n\n    public commandEncoder: GPUCommandEncoder;\n    public renderPassEncoder: GPURenderPassEncoder;\n    public commandFinished: Promise<void>;\n\n    private _resolveCommandFinished: (value: void) => void;\n\n    private _gpu: GPU;\n    private _boundBindGroup: Record<number, BindGroup> = Object.create(null);\n    private _boundVertexBuffer: Record<number, Buffer> = Object.create(null);\n    private _boundIndexBuffer: Buffer;\n    private _boundPipeline: GPURenderPipeline;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public renderStart(): void\n    {\n        this.commandFinished = new Promise((resolve) =>\n        {\n            this._resolveCommandFinished = resolve;\n        });\n\n        // generate a render pass description..\n        // create an encoder..\n        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    }\n\n    public beginRenderPass(gpuRenderTarget: GpuRenderTarget)\n    {\n        this.endRenderPass();\n\n        this._clearCache();\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n    }\n\n    public endRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n        }\n\n        this.renderPassEncoder = null;\n    }\n\n    public setViewport(viewport: Rectangle): void\n    {\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    }\n\n    public setPipelineFromGeometryProgramAndState(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: any,\n        topology?: Topology,\n    ): void\n    {\n        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n\n        this.setPipeline(pipeline);\n    }\n\n    public setPipeline(pipeline: GPURenderPipeline)\n    {\n        if (this._boundPipeline === pipeline) return;\n        this._boundPipeline = pipeline;\n\n        this.renderPassEncoder.setPipeline(pipeline);\n    }\n\n    private _setVertexBuffer(index: number, buffer: Buffer)\n    {\n        if (this._boundVertexBuffer[index] === buffer) return;\n\n        this._boundVertexBuffer[index] = buffer;\n\n        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n    }\n\n    private _setIndexBuffer(buffer: Buffer)\n    {\n        if (this._boundIndexBuffer === buffer) return;\n\n        this._boundIndexBuffer = buffer;\n\n        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? 'uint16' : 'uint32';\n\n        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n    }\n\n    public resetBindGroup(index: number)\n    {\n        this._boundBindGroup[index] = null;\n    }\n\n    public setBindGroup(index: number, bindGroup: BindGroup, program: GpuProgram)\n    {\n        if (this._boundBindGroup[index] === bindGroup) return;\n        this._boundBindGroup[index] = bindGroup;\n\n        bindGroup._touch(this._renderer.textureGC.count);\n\n        // TODO getting the bind group works as it looks at th e assets and generates a key\n        // should this just be hidden behind a dirty flag?\n        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n\n        // mark each item as having been used..\n        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n    }\n\n    public setGeometry(geometry: Geometry)\n    {\n        for (const i in geometry.attributes)\n        {\n            const attribute = geometry.attributes[i];\n\n            this._setVertexBuffer(attribute.location, attribute.buffer);\n        }\n\n        if (geometry.indexBuffer)\n        {\n            this._setIndexBuffer(geometry.indexBuffer);\n        }\n    }\n\n    private _setShaderBindGroups(shader: Shader, skipSync?: boolean)\n    {\n        for (const i in shader.groups)\n        {\n            const bindGroup = shader.groups[i] as BindGroup;\n\n            // update any uniforms?\n            if (!skipSync)\n            {\n                this._syncBindGroup(bindGroup);\n            }\n\n            this.setBindGroup(i as unknown as number, bindGroup, shader.gpuProgram);\n        }\n    }\n\n    private _syncBindGroup(bindGroup: BindGroup)\n    {\n        for (const j in bindGroup.resources)\n        {\n            const resource = bindGroup.resources[j];\n\n            if ((resource as UniformGroup).isUniformGroup)\n            {\n                this._renderer.ubo.updateUniformGroup(resource as UniformGroup);\n            }\n        }\n    }\n\n    public draw(options: {\n        geometry: Geometry;\n        shader: Shader;\n        state?: State;\n        topology?: Topology;\n        size?: number;\n        start?: number;\n        instanceCount?: number;\n        skipSync?: boolean;\n    })\n    {\n        const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n\n        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n        this.setGeometry(geometry);\n        this._setShaderBindGroups(shader, skipSync);\n\n        if (geometry.indexBuffer)\n        {\n            this.renderPassEncoder.drawIndexed(\n                size || geometry.indexBuffer.data.length,\n                instanceCount || geometry.instanceCount,\n                start || 0\n            );\n        }\n        else\n        {\n            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start || 0);\n        }\n    }\n\n    public finishRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n            this.renderPassEncoder = null;\n        }\n    }\n\n    public postrender()\n    {\n        this.finishRenderPass();\n\n        this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n\n        this._resolveCommandFinished();\n\n        this.commandEncoder = null;\n    }\n\n    // restores a render pass if finishRenderPass was called\n    // not optimised as really used for debugging!\n    // used when we want to stop drawing and log a texture..\n    public restoreRenderPass()\n    {\n        const descriptor = (this._renderer.renderTarget.adaptor as GpuRenderTargetAdaptor).getDescriptor(\n            this._renderer.renderTarget.renderTarget,\n            false,\n            [0, 0, 0, 1],\n        );\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n\n        const boundPipeline = this._boundPipeline;\n        const boundVertexBuffer = { ...this._boundVertexBuffer };\n        const boundIndexBuffer = this._boundIndexBuffer;\n        const boundBindGroup = { ...this._boundBindGroup };\n\n        this._clearCache();\n\n        const viewport = this._renderer.renderTarget.viewport;\n\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n        // reinstate the cache...\n\n        this.setPipeline(boundPipeline);\n\n        for (const i in boundVertexBuffer)\n        {\n            this._setVertexBuffer(i as unknown as number, boundVertexBuffer[i]);\n        }\n\n        for (const i in boundBindGroup)\n        {\n            this.setBindGroup(i as unknown as number, boundBindGroup[i], null);\n        }\n\n        this._setIndexBuffer(boundIndexBuffer);\n    }\n\n    private _clearCache()\n    {\n        for (let i = 0; i < 16; i++)\n        {\n            this._boundBindGroup[i] = null;\n            this._boundVertexBuffer[i] = null;\n        }\n\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._gpu = null;\n        this._boundBindGroup = null;\n        this._boundVertexBuffer = null;\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuProgram } from './GpuProgram';\n\nexport interface GPUProgramData\n{\n    bindGroups: GPUBindGroupLayout[]\n    pipeline: GPUPipelineLayout\n}\n\n/**\n * A system that manages the rendering of GpuPrograms.\n * @memberof rendering\n */\nexport class GpuShaderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    private _gpu: GPU;\n\n    private readonly _gpuProgramData: Record<number, GPUProgramData> = Object.create(null);\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getProgramData(program: GpuProgram)\n    {\n        return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n    }\n\n    private _createGPUProgramData(program: GpuProgram)\n    {\n        const device = this._gpu.device;\n\n        const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n\n        const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n\n        this._gpuProgramData[program._layoutKey] = {\n            bindGroups,\n            pipeline: device.createPipelineLayout(pipelineLayoutDesc),\n        };\n\n        // generally we avoid having to make this automatically\n        // keeping this for a reminder, if any issues popup\n        // program._gpuLayout = {\n        //     bindGroups: null,\n        //     pipeline: 'auto',\n        // };\n\n        return this._gpuProgramData[program._layoutKey];\n    }\n\n    public destroy(): void\n    {\n        // TODO destroy the _gpuProgramData\n        this._gpu = null;\n        (this._gpuProgramData as null) = null;\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { CanvasPool } from '../../shared/texture/CanvasPool';\nimport { BindGroup } from '../shader/BindGroup';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource';\nimport { blockDataMap, gpuUploadCompressedTextureResource } from './uploaders/gpuUploadCompressedTextureResource';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture, Texture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuTextureUploader } from './uploaders/GpuTextureUploader';\n\n/**\n * The system that handles textures for the GPU.\n * @memberof rendering\n */\nexport class GpuTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    protected CONTEXT_UID: number;\n    private _gpuSources: Record<number, GPUTexture> = Object.create(null);\n    private _gpuSamplers: Record<string, GPUSampler> = Object.create(null);\n    private _bindGroupHash: Record<string, BindGroup> = Object.create(null);\n    private _textureViewHash: Record<string, GPUTextureView> = Object.create(null);\n\n    private readonly _uploads: Record<string, GpuTextureUploader> = {\n        image: gpuUploadImageResource,\n        buffer: gpuUploadBufferImageResource,\n        video: gpuUploadVideoResource,\n        compressed: gpuUploadCompressedTextureResource\n    };\n\n    private _gpu: GPU;\n    private _mipmapGenerator?: GpuMipmapGenerator;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public initSource(source: TextureSource): GPUTexture\n    {\n        if (source.autoGenerateMipmaps)\n        {\n            const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n\n        if (source.uploadMethodId !== 'compressed')\n        {\n            usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n            usage |= GPUTextureUsage.COPY_SRC;\n        }\n\n        const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n        const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n        const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n\n        const textureDescriptor: GPUTextureDescriptor = {\n            label: source.label,\n            size: { width, height },\n            format: source.format,\n            sampleCount: source.sampleCount,\n            mipLevelCount: source.mipLevelCount,\n            dimension: source.dimension,\n            usage\n        };\n\n        const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n\n        this._gpuSources[source.uid] = gpuTexture;\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceResize, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n\n        return gpuTexture;\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gpuTexture = this.getGpuSource(source);\n\n        // destroyed!\n        if (!gpuTexture) return;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source);\n        }\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (gpuTexture)\n        {\n            this._gpuSources[source.uid] = null;\n\n            gpuTexture.destroy();\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource): void\n    {\n        if (!this._mipmapGenerator)\n        {\n            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n        }\n\n        const gpuTexture = this.getGpuSource(source);\n\n        this._mipmapGenerator.generateMipmap(gpuTexture);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('update', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('resize', this.onSourceResize, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    protected onSourceResize(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (!gpuTexture)\n        {\n            this.initSource(source);\n        }\n        else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight)\n        {\n            this._textureViewHash[source.uid] = null;\n            this._bindGroupHash[source.uid] = null;\n\n            this.onSourceUnload(source);\n            this.initSource(source);\n        }\n    }\n\n    private _initSampler(sampler: TextureStyle): GPUSampler\n    {\n        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n\n        return this._gpuSamplers[sampler._resourceId];\n    }\n\n    public getGpuSampler(sampler: TextureStyle): GPUSampler\n    {\n        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGpuSource(source: TextureSource): GPUTexture\n    {\n        return this._gpuSources[source.uid] || this.initSource(source);\n    }\n\n    public getTextureBindGroup(texture: Texture)\n    {\n        return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n    }\n\n    private _createTextureBindGroup(texture: BindableTexture)\n    {\n        const source = texture.source;\n\n        const bindGroupId = source.uid;\n\n        this._bindGroupHash[bindGroupId] = new BindGroup({\n            0: source,\n            1: source.style,\n        });\n\n        return this._bindGroupHash[bindGroupId];\n    }\n\n    public getTextureView(texture: BindableTexture)\n    {\n        const source = texture.source;\n\n        return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n    }\n\n    private _createTextureView(texture: TextureSource)\n    {\n        this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n\n        return this._textureViewHash[texture.uid];\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const renderer = this._renderer;\n\n        const commandEncoder = renderer.gpu.device.createCommandEncoder();\n\n        // create canvas\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = texture.source.pixelWidth;\n        canvas.height = texture.source.pixelHeight;\n\n        const context = canvas.getContext('webgpu') as unknown as GPUCanvasContext;\n\n        context.configure({\n            device: renderer.gpu.device,\n            // eslint-disable-next-line max-len\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n            format: navigator.gpu.getPreferredCanvasFormat(),\n            alphaMode: 'premultiplied',\n        });\n\n        commandEncoder.copyTextureToTexture({\n            texture: renderer.texture.getGpuSource(texture.source),\n            origin: {\n                x: 0,\n                y: 0,\n            },\n        }, {\n            texture: context.getCurrentTexture(),\n        }, {\n            width: canvas.width,\n            height: canvas.height,\n        });\n\n        renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const webGPUCanvas = this.generateCanvas(texture);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n\n        const context = canvasAndContext.context;\n\n        context.drawImage(webGPUCanvas, 0, 0);\n\n        const { width, height } = webGPUCanvas;\n\n        const imageData = context.getImageData(0, 0, width, height);\n\n        const pixels = new Uint8ClampedArray(imageData.data.buffer);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return { pixels, width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the aarry with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n\n        for (const k of Object.keys(this._bindGroupHash))\n        {\n            const key = Number(k);\n            const bindGroup = this._bindGroupHash[key];\n\n            bindGroup?.destroy();\n            this._bindGroupHash[key] = null;\n        }\n\n        this._gpu = null;\n        this._mipmapGenerator = null;\n        this._gpuSources = null;\n        this._bindGroupHash = null;\n        this._textureViewHash = null;\n        this._gpuSamplers = null;\n    }\n}\n","import type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\nexport const gpuUploadImageResource = {\n\n    type: 'image',\n\n    upload(source: TextureSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource as ImageBitmap | HTMLCanvasElement | OffscreenCanvas;\n\n        if (!resource) return;\n\n        const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n        const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        gpu.device.queue.copyExternalImageToTexture(\n            { source: resource },\n            { texture: gpuTexture, premultipliedAlpha },\n            {\n                width,\n                height,\n            }\n        );\n    }\n} as GpuTextureUploader<TextureSource>;\n\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { MAX_TEXTURES } from '../../../rendering/batcher/shared/const';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { GpuEncoderSystem } from '../../../rendering/renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses the GPU to render graphics.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    public init()\n    {\n        const localUniforms = new UniformGroup({\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'graphics',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(MAX_TEXTURES),\n\n                localUniformBitGroup2,\n                roundPixelsBit\n            ]\n        });\n\n        this.shader = new Shader({\n            gpuProgram,\n            resources: {\n                // added on the fly!\n                localUniforms,\n            },\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGPURenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            geometry, instructions\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGPU specific...\n\n        // TODO perf test this a bit...\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        encoder.setPipelineFromGeometryProgramAndState(\n            geometry,\n            shader.gpuProgram,\n            graphicsPipe.state\n        );\n\n        encoder.setGeometry(geometry);\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n\n        const localBindGroup = (renderer as WebGPURenderer)\n            .renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n\n        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            shader.groups[1] = batch.bindGroup;\n\n            if (!batch.gpuBindGroup)\n            {\n                const textureBatch = batch.textures;\n\n                batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n                batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n                    batch.bindGroup, shader.gpuProgram, 1\n                );\n            }\n\n            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n\n            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit } from '../../high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../renderers/shared/shader/Shader';\nimport { State } from '../../renderers/shared/state/State';\nimport { MAX_TEXTURES } from '../shared/const';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup';\n\nimport type { GpuEncoderSystem } from '../../renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\nconst tempState = State.for2d();\n\n/**\n * A BatcherAdaptor that uses the GPU to render batches.\n * @memberof rendering\n * @ignore\n */\nexport class GpuBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private _shader: Shader;\n    private _geometry: Geometry;\n\n    public init()\n    {\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'batch',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(MAX_TEXTURES),\n                roundPixelsBit,\n            ]\n        });\n\n        this._shader = new Shader({\n            gpuProgram,\n            groups: {\n                // these will be dynamically allocated\n            },\n        });\n    }\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry): void\n    {\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n        const program = this._shader.gpuProgram;\n\n        this._geometry = geometry;\n\n        encoder.setGeometry(geometry);\n\n        tempState.blendMode = 'normal';\n\n        // this just initiates the pipeline, so we can then set bind groups on it\n        renderer.pipeline.getPipeline(\n            geometry,\n            program,\n            tempState\n        );\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        // low level - we need to reset the bind group at location 1 to null\n        // this is because we directly manipulate the bound buffer in the execture function for\n        // performance reasons.\n        // setting it to null ensures that the next bind group we set at location 1 will\n        // be the one we want.\n        encoder.resetBindGroup(1);\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, program);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const program = this._shader.gpuProgram;\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        if (!batch.bindGroup)\n        {\n            const textureBatch = batch.textures;\n\n            batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n        }\n\n        tempState.blendMode = batch.blendMode;\n\n        const gpuBindGroup = renderer.bindGroup.getBindGroup(\n            batch.bindGroup, program, 1\n        );\n\n        const pipeline = renderer.pipeline.getPipeline(\n            this._geometry,\n            program,\n            tempState\n        );\n\n        batch.bindGroup._touch(renderer.textureGC.count);\n\n        encoder.setPipeline(pipeline);\n\n        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n","import type { Buffer } from '../../shared/buffer/Buffer';\n\nexport class UboBatch\n{\n    private _buffer: Buffer;\n    public data: Float32Array;\n    private readonly _minUniformOffsetAlignment: number = 256;\n\n    public byteIndex = 0;\n\n    constructor({ minUniformOffsetAlignment }: {minUniformOffsetAlignment: number})\n    {\n        this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n        this.data = new Float32Array(65535);\n    }\n\n    public clear(): void\n    {\n        this.byteIndex = 0;\n    }\n\n    public addEmptyGroup(size: number): number\n    {\n        // update the buffer.. only float32 for now!\n        if (size > this._minUniformOffsetAlignment / 4)\n        {\n            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n        }\n\n        const start = this.byteIndex;\n\n        let newSize = start + (size * 4);\n\n        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n\n        if (newSize > this.data.length * 4)\n        {\n            // TODO push a new buffer\n            throw new Error('UniformBufferBatch: ubo batch got too big');\n        }\n\n        this.byteIndex = newSize;\n\n        return start;\n    }\n\n    public addGroup(array: Float32Array): number\n    {\n        const offset = this.addEmptyGroup(array.length);\n\n        for (let i = 0; i < array.length; i++)\n        {\n            this.data[(offset / 4) + i] = array[i];\n        }\n\n        return offset;\n    }\n\n    public destroy()\n    {\n        this._buffer.destroy();\n        this._buffer = null;\n\n        this.data = null;\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\nexport interface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in\n * @name CanvasPool\n * @memberof rendering\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const { width, height } = canvasAndContext.canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\nexport const CanvasPool = new CanvasPoolClass();\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { State } from '../../shared/state/State';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\n\n/**\n * System plugin to the renderer to manage WebGL state machines.\n * @memberof rendering\n */\nexport class GpuStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'state',\n    } as const;\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @member {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gpu: GPU;\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    constructor()\n    {\n        this.defaultState = new State();\n        this.defaultState.blend = true;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this.gpu = gpu;\n    }\n\n    /**\n     * Gets the blend mode data for the current state\n     * @param state - The state to get the blend mode from\n     */\n    public getColorTargets(state: State): GPUColorTargetState[]\n    {\n        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n\n        return [\n            {\n                format: 'bgra8unorm',\n                writeMask: 0,\n                blend,\n            },\n        ];\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Buffer } from '../shared/buffer/Buffer';\nimport { BufferResource } from '../shared/buffer/BufferResource';\nimport { BufferUsage } from '../shared/buffer/const';\nimport { UboBatch } from './buffer/UboBatch';\nimport { BindGroup } from './shader/BindGroup';\n\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\nconst minUniformOffsetAlignment = 128;// 256 / 2;\n\n// TODO renderStart and renderFinish - perhaps just make them instructions to fit the architecture of the\n// rest of the system\nexport class GpuUniformBatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'uniformBatch',\n    } as const;\n\n    private _renderer: WebGPURenderer;\n\n    private _bindGroupHash: Record<number, BindGroup> = Object.create(null);\n    private readonly _batchBuffer: UboBatch;\n\n    // number of buffers..\n    private _buffers: Buffer[] = [];\n\n    private _bindGroups: BindGroup[] = [];\n    private _bufferResources: BufferResource[] = [];\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n\n        const totalBuffers = (256 / minUniformOffsetAlignment);\n\n        for (let i = 0; i < totalBuffers; i++)\n        {\n            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n\n            if (i === 0) usage |= BufferUsage.COPY_SRC;\n\n            this._buffers.push(new Buffer({\n                data: this._batchBuffer.data,\n                usage\n            }));\n        }\n    }\n\n    public renderEnd()\n    {\n        this._uploadBindGroups();\n        this._resetBindGroups();\n    }\n\n    private _resetBindGroups()\n    {\n        for (const i in this._bindGroupHash)\n        {\n            this._bindGroupHash[i] = null;\n        }\n\n        this._batchBuffer.clear();\n    }\n\n    // just works for single bind groups for now\n    public getUniformBindGroup(group: UniformGroup<any>, duplicate: boolean): BindGroup\n    {\n        if (!duplicate && this._bindGroupHash[group.uid])\n        {\n            return this._bindGroupHash[group.uid];\n        }\n\n        this._renderer.ubo.ensureUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addEmptyGroup(data.length);\n\n        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n\n        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n\n        return this._bindGroupHash[group.uid];\n    }\n\n    public getUboResource(group: UniformGroup<any>): BufferResource\n    {\n        this._renderer.ubo.updateUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBufferResource(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBindGroup(data: Float32Array): BindGroup\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBindGroup(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBufferResource(data: Float32Array): BufferResource\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        const index = offset / minUniformOffsetAlignment;\n\n        return this._getBufferResource(index);\n    }\n\n    private _getBufferResource(index: number): BufferResource\n    {\n        if (!this._bufferResources[index])\n        {\n            const buffer = this._buffers[index % 2];\n\n            this._bufferResources[index] = new BufferResource({\n                buffer,\n                offset: ((index / 2) | 0) * 256,\n                size: minUniformOffsetAlignment\n            });\n        }\n\n        return this._bufferResources[index];\n    }\n\n    private _getBindGroup(index: number): BindGroup\n    {\n        if (!this._bindGroups[index])\n        {\n            // even!\n            const bindGroup = new BindGroup({\n                0: this._getBufferResource(index),\n            });\n\n            this._bindGroups[index] = bindGroup;\n        }\n\n        return this._bindGroups[index];\n    }\n\n    private _uploadBindGroups()\n    {\n        const bufferSystem = this._renderer.buffer;\n\n        const firstBuffer = this._buffers[0];\n\n        firstBuffer.update(this._batchBuffer.byteIndex);\n\n        bufferSystem.updateBuffer(firstBuffer);\n\n        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n\n        for (let i = 1; i < this._buffers.length; i++)\n        {\n            const buffer = this._buffers[i];\n\n            commandEncoder.copyBufferToBuffer(\n                bufferSystem.getGPUBuffer(firstBuffer),\n                minUniformOffsetAlignment,\n                bufferSystem.getGPUBuffer(buffer),\n                0,\n                this._batchBuffer.byteIndex\n            );\n        }\n\n        // TODO make a system that will que up all commands in to one array?\n        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this._bindGroups.length; i++)\n        {\n            this._bindGroups[i].destroy();\n        }\n\n        this._bindGroups = null;\n        this._bindGroupHash = null;\n\n        for (let i = 0; i < this._buffers.length; i++)\n        {\n            this._buffers[i].destroy();\n        }\n        this._buffers = null;\n\n        for (let i = 0; i < this._bufferResources.length; i++)\n        {\n            this._bufferResources[i].destroy();\n        }\n\n        this._bufferResources = null;\n\n        this._batchBuffer.destroy();\n        this._bindGroupHash = null;\n\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles color masking for the GPU.\n * @memberof rendering\n */\nexport class GpuColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.pipeline.setColorMask(colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorMaskCache = null;\n    }\n}\n","import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\nexport const blockDataMap: Record<string, {blockBytes: number, blockWidth: number, blockHeight: number}> = {\n    'bc1-rgba-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'bc2-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc3-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc7-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'etc1-rgb-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'etc2-rgba8unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'astc-4x4-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n};\n\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\nexport const gpuUploadCompressedTextureResource = {\n\n    type: 'compressed',\n\n    upload(source: CompressedSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const blockData = blockDataMap[source.format] || defaultBlockData;\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n\n            gpu.device.queue.writeTexture(\n                {\n                    texture: gpuTexture,\n                    mipLevel: i\n                },\n                levelBuffer,\n                {\n                    offset: 0,\n                    bytesPerRow,\n                },\n                {\n                    width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n                    height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n                    depthOrArrayLayers: 1,\n                }\n            );\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GpuTextureUploader<CompressedSource>;\n\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @memberof rendering\n */\nexport class GpuStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        this._activeRenderTarget = renderTarget;\n\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        const renderer = this._renderer;\n\n        renderer.pipeline.setStencilMode(stencilMode);\n        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n    }\n\n    public destroy()\n    {\n        this._renderer.renderTarget.onRenderTargetChange.remove(this);\n\n        (this._renderer as null) = null;\n\n        this._activeRenderTarget = null;\n        this._renderTargetStencilState = null;\n    }\n}\n","import type { BLEND_MODES } from '../../shared/state/const';\n\nexport const GpuBlendModesToPixi: Partial<Record<BLEND_MODES, GPUBlendState>> = {};\n\nGpuBlendModesToPixi.normal = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.add = {\n    alpha: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.multiply = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'dst',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.screen = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.overlay = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.none = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'zero',\n        operation: 'add',\n    },\n};\n\n// not-premultiplied blend modes\nGpuBlendModesToPixi['normal-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['add-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['screen-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.erase = {\n    alpha: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\n// composite operations\n// GpuBlendModesToPixi[BLEND_MODES.SRC_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OVER] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.XOR] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// TODO - fix me\n// GLBlendModesToPixi[BLEND_MODES.SUBTRACT] = {\n//     alpha: {\n//         srcFactor: 'one',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n","import { gpuUploadImageResource } from './gpuUploadImageSource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\nexport const gpuUploadVideoResource = {\n\n    type: 'video',\n\n    upload(source: VideoSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        gpuUploadImageResource.upload(source, gpuTexture, gpu);\n    }\n} as GpuTextureUploader<VideoSource>;\n\n","import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the wgsl layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n */\nexport function generateArraySyncWGSL(uboElement: UboElement, offsetToAdd: number): string\n{\n    // this is in byte..\n    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n\n    const remainder = (align - size) / 4;\n\n    return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ''}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 data[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n         }\n     `;\n}\n","/**\n * A class which generates mipmaps for a GPUTexture.\n * Thanks to @toji for the original implementation\n * https://github.com/toji/web-texture-tool/blob/main/src/webgpu-mipmap-generator.js\n * @memberof rendering\n * @ignore\n */\nexport class GpuMipmapGenerator\n{\n    public device: GPUDevice;\n    public sampler: GPUSampler;\n    public pipelines: Record<string, GPURenderPipeline>;\n\n    public mipmapShaderModule: any;\n\n    constructor(device: GPUDevice)\n    {\n        this.device = device;\n        this.sampler = device.createSampler({ minFilter: 'linear' });\n        // We'll need a new pipeline for every texture format used.\n        this.pipelines = {};\n    }\n\n    private _getMipmapPipeline(format: GPUTextureFormat)\n    {\n        let pipeline = this.pipelines[format];\n\n        if (!pipeline)\n        {\n            // Shader modules is shared between all pipelines, so only create once.\n            if (!this.mipmapShaderModule)\n            {\n                this.mipmapShaderModule = this.device.createShaderModule({\n                    code: /* wgsl */ `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `,\n                });\n            }\n\n            pipeline = this.device.createRenderPipeline({\n                layout: 'auto',\n                vertex: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'vertexMain',\n                },\n                fragment: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'fragmentMain',\n                    targets: [{ format }],\n                }\n            });\n\n            this.pipelines[format] = pipeline;\n        }\n\n        return pipeline;\n    }\n\n    /**\n     * Generates mipmaps for the given GPUTexture from the data in level 0.\n     * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n     * @returns {module:External.GPUTexture} - The originally passed texture\n     */\n    public generateMipmap(texture: GPUTexture)\n    {\n        const pipeline = this._getMipmapPipeline(texture.format);\n\n        if (texture.dimension === '3d' || texture.dimension === '1d')\n        {\n            throw new Error('Generating mipmaps for non-2d textures is currently unsupported!');\n        }\n\n        let mipTexture = texture;\n        const arrayLayerCount = texture.depthOrArrayLayers || 1; // Only valid for 2D textures.\n\n        // If the texture was created with RENDER_ATTACHMENT usage we can render directly between mip levels.\n        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n\n        if (!renderToSource)\n        {\n            // Otherwise we have to use a separate texture to render into. It can be one mip level smaller than the source\n            // texture, since we already have the top level.\n            const mipTextureDescriptor = {\n                size: {\n                    width: Math.ceil(texture.width / 2),\n                    height: Math.ceil(texture.height / 2),\n                    depthOrArrayLayers: arrayLayerCount,\n                },\n                format: texture.format,\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n                mipLevelCount: texture.mipLevelCount - 1,\n            };\n\n            mipTexture = this.device.createTexture(mipTextureDescriptor);\n        }\n\n        const commandEncoder = this.device.createCommandEncoder({});\n        // TODO: Consider making this static.\n        const bindGroupLayout = pipeline.getBindGroupLayout(0);\n\n        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer)\n        {\n            let srcView = texture.createView({\n                baseMipLevel: 0,\n                mipLevelCount: 1,\n                dimension: '2d',\n                baseArrayLayer: arrayLayer,\n                arrayLayerCount: 1,\n            });\n\n            let dstMipLevel = renderToSource ? 1 : 0;\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                const dstView = mipTexture.createView({\n                    baseMipLevel: dstMipLevel++,\n                    mipLevelCount: 1,\n                    dimension: '2d',\n                    baseArrayLayer: arrayLayer,\n                    arrayLayerCount: 1,\n                });\n\n                const passEncoder = commandEncoder.beginRenderPass({\n                    colorAttachments: [{\n                        view: dstView,\n                        storeOp: 'store',\n                        loadOp: 'clear',\n                        clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    }],\n                });\n\n                const bindGroup = this.device.createBindGroup({\n                    layout: bindGroupLayout,\n                    entries: [{\n                        binding: 0,\n                        resource: this.sampler,\n                    }, {\n                        binding: 1,\n                        resource: srcView,\n                    }],\n                });\n\n                passEncoder.setPipeline(pipeline);\n                passEncoder.setBindGroup(0, bindGroup);\n                passEncoder.draw(3, 1, 0, 0);\n\n                passEncoder.end();\n\n                srcView = dstView;\n            }\n        }\n\n        // If we didn't render to the source texture, finish by copying the mip results from the temporary mipmap texture\n        // to the source.\n        if (!renderToSource)\n        {\n            const mipLevelSize = {\n                width: Math.ceil(texture.width / 2),\n                height: Math.ceil(texture.height / 2),\n                depthOrArrayLayers: arrayLayerCount,\n            };\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                commandEncoder.copyTextureToTexture({\n                    texture: mipTexture,\n                    mipLevel: i - 1,\n                }, {\n                    texture,\n                    mipLevel: i,\n                }, mipLevelSize);\n\n                mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n                mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n            }\n        }\n\n        this.device.queue.submit([commandEncoder.finish()]);\n\n        if (!renderToSource)\n        {\n            mipTexture.destroy();\n        }\n\n        return texture;\n    }\n}\n","import { CLEAR } from '../../gl/const';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport { GpuRenderTarget } from './GpuRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * The WebGPU adaptor for the render target system. Allows the Render Target System to\n * be used with the WebGPU renderer\n * @memberof rendering\n * @ignore\n */\nexport class GpuRenderTargetAdaptor implements RenderTargetAdaptor<GpuRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GpuRenderTarget>;\n    private _renderer: WebGPURenderer<HTMLCanvasElement>;\n\n    public init(renderer: WebGPURenderer, renderTargetSystem: RenderTargetSystem<GpuRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderer = this._renderer;\n\n        const baseGpuTexture = this._getGpuColorTexture(\n            sourceRenderSurfaceTexture\n        );\n\n        const backGpuTexture = renderer.texture.getGpuSource(\n            destinationTexture.source\n        );\n\n        renderer.encoder.commandEncoder.copyTextureToTexture(\n            {\n                texture: baseGpuTexture,\n                origin: originSrc,\n            },\n            {\n                texture: backGpuTexture,\n                origin: originDest,\n            },\n            size\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n        gpuRenderTarget.descriptor = descriptor;\n\n        // TODO we should not finish a render pass each time we bind\n        // for example filters - we would want to push / pop render targets\n        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n        this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n        this._renderer.encoder.setViewport(viewport);\n    }\n\n    public finishRenderPass()\n    {\n        this._renderer.encoder.endRenderPass();\n    }\n\n    /**\n     * returns the gpu texture for the first color texture in the render target\n     * mainly used by the filter manager to get copy the texture for blending\n     * @param renderTarget\n     * @returns a gpu texture\n     */\n    private _getGpuColorTexture(renderTarget: RenderTarget): GPUTexture\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (gpuRenderTarget.contexts[0])\n        {\n            return gpuRenderTarget.contexts[0].getCurrentTexture();\n        }\n\n        return this._renderer.texture.getGpuSource(\n            renderTarget.colorTextures[0].source\n        );\n    }\n\n    public getDescriptor(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearValue: RgbaArray\n    ): GPURenderPassDescriptor\n    {\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const colorAttachments = renderTarget.colorTextures.map(\n            (texture, i) =>\n            {\n                const context = gpuRenderTarget.contexts[i];\n\n                let view: GPUTextureView;\n                let resolveTarget: GPUTextureView;\n\n                if (context)\n                {\n                    const currentTexture = context.getCurrentTexture();\n\n                    const canvasTextureView = currentTexture.createView();\n\n                    view = canvasTextureView;\n                }\n                else\n                {\n                    view = this._renderer.texture.getGpuSource(texture).createView({\n                        mipLevelCount: 1,\n                    });\n                }\n\n                if (gpuRenderTarget.msaaTextures[i])\n                {\n                    resolveTarget = view;\n                    view = this._renderer.texture.getTextureView(\n                        gpuRenderTarget.msaaTextures[i]\n                    );\n                }\n\n                const loadOp = ((clear as CLEAR) & CLEAR.COLOR ? 'clear' : 'load') as GPULoadOp;\n\n                clearValue ??= renderTargetSystem.defaultClearColor;\n\n                return {\n                    view,\n                    resolveTarget,\n                    clearValue,\n                    storeOp: 'store',\n                    loadOp\n                };\n            }\n        ) as GPURenderPassColorAttachment[];\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment;\n\n        // if we have a depth or stencil buffer, we need to ensure we have a texture for it\n        // this is WebGPU specific - as WebGL does not require textures to run a depth / stencil buffer\n        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture)\n        {\n            renderTarget.ensureDepthStencilTexture();\n            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n        }\n\n        if (renderTarget.depthStencilTexture)\n        {\n            const stencilLoadOp = (clear & CLEAR.STENCIL ? 'clear' : 'load') as GPULoadOp;\n            const depthLoadOp = (clear & CLEAR.DEPTH ? 'clear' : 'load') as GPULoadOp;\n\n            depthStencilAttachment = {\n                view: this._renderer.texture\n                    .getGpuSource(renderTarget.depthStencilTexture.source)\n                    .createView(),\n                stencilStoreOp: 'store',\n                stencilLoadOp,\n                depthClearValue: 1.0,\n                depthLoadOp,\n                depthStoreOp: 'store',\n            };\n        }\n\n        const descriptor: GPURenderPassDescriptor = {\n            colorAttachments,\n            depthStencilAttachment,\n        };\n\n        return descriptor;\n    }\n\n    public clear(renderTarget: RenderTarget, clear: CLEAR_OR_BOOL = true, clearColor?: RgbaArray, viewport?: Rectangle)\n    {\n        if (!clear) return;\n\n        const { gpu, encoder } = this._renderer;\n\n        const device = gpu.device;\n\n        const standAlone = encoder.commandEncoder === null;\n\n        if (standAlone)\n        {\n            const commandEncoder = device.createCommandEncoder();\n            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n            passEncoder.end();\n\n            const gpuCommands = commandEncoder.finish();\n\n            device.queue.submit([gpuCommands]);\n        }\n        else\n        {\n            this.startRenderPass(renderTarget, clear, clearColor, viewport);\n        }\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GpuRenderTarget\n    {\n        // always false for WebGPU\n        renderTarget.isRoot = true;\n\n        const gpuRenderTarget = new GpuRenderTarget();\n\n        // create a context...\n        // is a canvas...\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (CanvasSource.test(colorTexture.resource))\n            {\n                const context = colorTexture.resource.getContext(\n                    'webgpu'\n                ) as unknown as GPUCanvasContext;\n\n                const alphaMode = (colorTexture as CanvasSource).transparent ? 'premultiplied' : 'opaque';\n\n                try\n                {\n                    context.configure({\n                        device: this._renderer.gpu.device,\n                        // eslint-disable-next-line max-len\n                        usage: GPUTextureUsage.TEXTURE_BINDING\n                            | GPUTextureUsage.COPY_DST\n                            | GPUTextureUsage.RENDER_ATTACHMENT\n                            | GPUTextureUsage.COPY_SRC,\n                        format: 'bgra8unorm',\n                        alphaMode,\n                    });\n                }\n                catch (e)\n                {\n                    console.error(e);\n                }\n\n                gpuRenderTarget.contexts[i] = context;\n            }\n\n            gpuRenderTarget.msaa = colorTexture.source.antialias;\n\n            if (colorTexture.source.antialias)\n            {\n                const msaaTexture = new TextureSource({\n                    width: 0,\n                    height: 0,\n                    sampleCount: 4,\n                });\n\n                gpuRenderTarget.msaaTextures[i] = msaaTexture;\n            }\n        });\n\n        if (gpuRenderTarget.msaa)\n        {\n            gpuRenderTarget.msaaSamples = 4;\n\n            if (renderTarget.depthStencilTexture)\n            {\n                renderTarget.depthStencilTexture.source.sampleCount = 4;\n            }\n        }\n\n        return gpuRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GpuRenderTarget)\n    {\n        gpuRenderTarget.contexts.forEach((context) =>\n        {\n            context.unconfigure();\n        });\n\n        gpuRenderTarget.msaaTextures.forEach((texture) =>\n        {\n            texture.destroy();\n        });\n\n        gpuRenderTarget.msaaTextures.length = 0;\n        gpuRenderTarget.contexts.length = 0;\n    }\n\n    public ensureDepthStencilTexture(renderTarget: RenderTarget)\n    {\n        // TODO This function will be more useful once we cache the descriptors\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa)\n        {\n            renderTarget.depthStencilTexture.source.sampleCount = 4;\n        }\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        gpuRenderTarget.width = renderTarget.width;\n        gpuRenderTarget.height = renderTarget.height;\n\n        if (gpuRenderTarget.msaa)\n        {\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const msaaTexture = gpuRenderTarget.msaaTextures[i];\n\n                msaaTexture?.resize(\n                    colorTexture.source.width,\n                    colorTexture.source.height,\n                    colorTexture.source._resolution\n                );\n            });\n        }\n    }\n}\n","import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { BindGroupSystem } from './BindGroupSystem';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem';\nimport { type GPU, GpuDeviceSystem } from './GpuDeviceSystem';\nimport { GpuEncoderSystem } from './GpuEncoderSystem';\nimport { GpuStencilSystem } from './GpuStencilSystem';\nimport { GpuUboSystem } from './GpuUboSystem';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe';\nimport { PipelineSystem } from './pipeline/PipelineSystem';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem';\nimport { GpuStateSystem } from './state/GpuStateSystem';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\n\nconst DefaultWebGPUSystems = [\n    ...SharedSystems,\n    GpuUboSystem,\n    GpuEncoderSystem,\n    GpuDeviceSystem,\n    GpuBufferSystem,\n    GpuTextureSystem,\n    GpuRenderTargetSystem,\n    GpuShaderSystem,\n    GpuStateSystem,\n    PipelineSystem,\n    GpuColorMaskSystem,\n    GpuStencilSystem,\n    BindGroupSystem,\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\n\ntype WebGPUSystems = ExtractSystemTypes<typeof DefaultWebGPUSystems> &\nPixiMixins.RendererSystems &\nPixiMixins.WebGPUSystems;\n\nexport type WebGPUPipes = ExtractSystemTypes<typeof DefaultWebGPUPipes> &\nPixiMixins.RendererPipes &\nPixiMixins.WebGPUPipes;\n\n/**\n * Options for WebGPURenderer.\n * @memberof rendering\n */\nexport interface WebGPUOptions extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGPUSystems>,\n    PixiMixins.WebGPUOptions{}\n\nexport interface WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>,\n    WebGPUSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGPU PixiJS Renderer. This renderer allows you to use the next-generation graphics API, WebGPU.\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGPURenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link rendering.autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n * ```ts\n * // Create a new renderer\n * const renderer = await rendering.autoDetectRenderer();\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGPU renderer:\n *\n * | WebGPU Core Systems                      | Systems that are specific to the WebGL renderer                               |\n * | ---------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link rendering.GpuUboSystem}           | This manages WebGPU uniform buffer objects feature for shaders                |\n * | {@link rendering.GpuEncoderSystem}       | This manages the WebGPU command encoder                                       |\n * | {@link rendering.GpuDeviceSystem}        | This manages the WebGPU Device and its extensions                             |\n * | {@link rendering.GpuBufferSystem}        | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link rendering.GpuTextureSystem}       | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link rendering.GpuRenderTargetSystem}  | This manages what we render too. For example the screen, or another texture   |\n * | {@link rendering.GpuShaderSystem}        | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link rendering.GpuStateSystem}         | This manages the state of the WebGPU Pipelines. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link rendering.PipelineSystem}         | This manages the WebGPU pipelines, used for rendering                         |\n * | {@link rendering.GpuColorMaskSystem}     | This manages the color mask. Used for color masking                           |\n * | {@link rendering.GpuStencilSystem}       | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link rendering.BindGroupSystem}        | This manages the WebGPU bind groups. this is how data is bound to a shader when rendering |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @memberof rendering\n * @property {rendering.GpuUboSystem} ubo - UboSystem instance.\n * @property {rendering.GpuEncoderSystem} encoder - EncoderSystem instance.\n * @property {rendering.GpuDeviceSystem} device - DeviceSystem instance.\n * @property {rendering.GpuBufferSystem} buffer - BufferSystem instance.\n * @property {rendering.GpuTextureSystem} texture - TextureSystem instance.\n * @property {rendering.GpuRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {rendering.GpuShaderSystem} shader - ShaderSystem instance.\n * @property {rendering.GpuStateSystem} state - StateSystem instance.\n * @property {rendering.PipelineSystem} pipeline - PipelineSystem instance.\n * @property {rendering.GpuColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @property {rendering.GpuStencilSystem} stencil - StencilSystem instance.\n * @property {rendering.BindGroupSystem} bindGroup - BindGroupSystem instance.\n * @extends rendering.AbstractRenderer\n */\nexport class WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>\n    implements WebGPUSystems\n{\n    /** The WebGPU Device. */\n    public gpu: GPU;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgpu',\n            type: RendererType.WEBGPU,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n","import type { BufferImageSource } from '../../../shared/texture/sources/BufferSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\nexport const gpuUploadBufferImageResource = {\n\n    type: 'image',\n\n    upload(source: BufferImageSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource;\n\n        const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n\n        const bytesPerPixel = resource.byteLength / total;\n\n        gpu.device.queue.writeTexture(\n            { texture: gpuTexture },\n            resource,\n            {\n                offset: 0,\n                rowsPerImage: source.pixelHeight,\n                bytesPerRow: source.pixelHeight * bytesPerPixel,\n            },\n            {\n                width: source.pixelWidth,\n                height: source.pixelHeight,\n                depthOrArrayLayers: 1,\n            }\n        );\n    }\n} as GpuTextureUploader<BufferImageSource>;\n\n","import type { UboElement, UboLayout, UNIFORM_TYPES, UniformData } from '../../../shared/shader/types';\n\nexport const WGSL_ALIGN_SIZE_DATA: Record<UNIFORM_TYPES | string, {align: number, size: number}> = {\n    i32: { align: 4, size: 4 },\n    u32: { align: 4, size: 4 },\n    f32: { align: 4, size: 4 },\n    f16: { align: 2, size: 2 },\n    'vec2<i32>': { align: 8, size: 8 },\n    'vec2<u32>': { align: 8, size: 8 },\n    'vec2<f32>': { align: 8, size: 8 },\n    'vec2<f16>': { align: 4, size: 4 },\n    'vec3<i32>': { align: 16, size: 12 },\n    'vec3<u32>': { align: 16, size: 12 },\n    'vec3<f32>': { align: 16, size: 12 },\n    'vec3<f16>': { align: 8, size: 6 },\n    'vec4<i32>': { align: 16, size: 16 },\n    'vec4<u32>': { align: 16, size: 16 },\n    'vec4<f32>': { align: 16, size: 16 },\n    'vec4<f16>': { align: 8, size: 8 },\n    'mat2x2<f32>': { align: 8, size: 16 },\n    'mat2x2<f16>': { align: 4, size: 8 },\n    'mat3x2<f32>': { align: 8, size: 24 },\n    'mat3x2<f16>': { align: 4, size: 12 },\n    'mat4x2<f32>': { align: 8, size: 32 },\n    'mat4x2<f16>': { align: 4, size: 16 },\n    'mat2x3<f32>': { align: 16, size: 32 },\n    'mat2x3<f16>': { align: 8, size: 16 },\n    'mat3x3<f32>': { align: 16, size: 48 },\n    'mat3x3<f16>': { align: 8, size: 24 },\n    'mat4x3<f32>': { align: 16, size: 64 },\n    'mat4x3<f16>': { align: 8, size: 32 },\n    'mat2x4<f32>': { align: 16, size: 32 },\n    'mat2x4<f16>': { align: 8, size: 16 },\n    'mat3x4<f32>': { align: 16, size: 48 },\n    'mat3x4<f16>': { align: 8, size: 24 },\n    'mat4x4<f32>': { align: 16, size: 64 },\n    'mat4x4<f16>': { align: 8, size: 32 },\n};\n\nexport function createUboElementsWGSL(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n        const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n\n        if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type])\n        {\n            throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, align) * uboElement.data.size;\n        }\n\n        offset = Math.ceil((offset) / align) * align;\n\n        // TODO deal with Arrays\n        uboElement.size = size;\n\n        uboElement.offset = offset;\n\n        offset += size;\n    }\n\n    // must align to 16 bits!\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n","import type { TextureSource } from '../../shared/texture/sources/TextureSource';\n\n/**\n * A class which holds the canvas contexts and textures for a render target.\n * @memberof rendering\n * @ignore\n */\nexport class GpuRenderTarget\n{\n    public contexts: GPUCanvasContext[] = [];\n    public msaaTextures: TextureSource[] = [];\n    public msaa: boolean;\n    public msaaSamples = 1;\n    public width: number;\n    public height: number;\n    public descriptor: GPURenderPassDescriptor;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes';\nimport { STENCIL_MODES } from '../../shared/state/const';\nimport { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { State } from '../../shared/state/State';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuRenderTarget } from '../renderTarget/GpuRenderTarget';\nimport type { GpuProgram } from '../shader/GpuProgram';\nimport type { StencilState } from '../state/GpuStencilModesToPixi';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\nconst topologyStringToId = {\n    'point-list': 0,\n    'line-list': 1,\n    'line-strip': 2,\n    'triangle-list': 3,\n    'triangle-strip': 4,\n};\n\n// geometryLayouts = 256; // 8 bits // 256 states // value 0-255;\n// shaderKeys = 256; // 8 bits // 256 states // value 0-255;\n// state = 64; // 6 bits // 64 states // value 0-63;\n// blendMode = 32; // 5 bits // 32 states // value 0-31;\n// topology = 8; // 3 bits // 8 states // value 0-7;\nfunction getGraphicsStateKey(\n    geometryLayout: number,\n    shaderKey: number,\n    state: number,\n    blendMode: number,\n    topology: number,\n): number\n{\n    return (geometryLayout << 24) // Allocate the 8 bits for geometryLayouts at the top\n         | (shaderKey << 16) // Next 8 bits for shaderKeys\n         | (state << 10) // 6 bits for state\n         | (blendMode << 5) // 5 bits for blendMode\n         | topology; // And 3 bits for topology at the least significant position\n}\n\n// colorMask = 16;// 4 bits // 16 states // value 0-15;\n// stencilState = 8; // 3 bits // 8 states // value 0-7;\n// renderTarget = 1; // 2 bit // 3 states // value 0-3; // none, stencil, depth, depth-stencil\n// multiSampleCount = 1; // 1 bit // 2 states // value 0-1;\nfunction getGlobalStateKey(\n    stencilStateId: number,\n    multiSampleCount: number,\n    colorMask: number,\n    renderTarget: number,\n): number\n{\n    return (colorMask << 6) // Allocate the 4 bits for colorMask at the top\n         | (stencilStateId << 3) // Next 3 bits for stencilStateId\n         | (renderTarget << 1) // 2 bits for renderTarget\n         | multiSampleCount; // And 1 bit for multiSampleCount at the least significant position\n}\n\ntype PipeHash = Record<number, GPURenderPipeline>;\n\n/**\n * A system that creates and manages the GPU pipelines.\n *\n * Caching Mechanism: At its core, the system employs a two-tiered caching strategy to minimize\n * the redundant creation of GPU pipelines (or \"pipes\"). This strategy is based on generating unique\n * keys that represent the state of the graphics settings and the specific requirements of the\n * item being rendered. By caching these pipelines, subsequent draw calls with identical configurations\n * can reuse existing pipelines instead of generating new ones.\n *\n * State Management: The system differentiates between \"global\" state properties (like color masks\n * and stencil masks, which do not change frequently) and properties that may vary between draw calls\n * (such as geometry, shaders, and blend modes). Unique keys are generated for both these categories\n * using getStateKey for global state and getGraphicsStateKey for draw-specific settings. These keys are\n * then then used to caching the pipe. The next time we need a pipe we can check\n * the cache by first looking at the state cache and then the pipe cache.\n * @memberof rendering\n */\nexport class PipelineSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'pipeline',\n    } as const;\n    private readonly _renderer: WebGPURenderer;\n\n    protected CONTEXT_UID: number;\n\n    private _moduleCache: Record<string, GPUShaderModule> = Object.create(null);\n    private _bufferLayoutsCache: Record<number, GPUVertexBufferLayout[]> = Object.create(null);\n\n    private _pipeCache: PipeHash = Object.create(null);\n    private readonly _pipeStateCaches: Record<number, PipeHash> = Object.create(null);\n\n    private _gpu: GPU;\n    private _stencilState: StencilState;\n\n    private _stencilMode: STENCIL_MODES;\n    private _colorMask = 0b1111;\n    private _multisampleCount = 1;\n    private _depthStencilAttachment: 0 | 1;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n        this.setStencilMode(STENCIL_MODES.DISABLED);\n\n        this._updatePipeHash();\n    }\n\n    public setMultisampleCount(multisampleCount: number): void\n    {\n        if (this._multisampleCount === multisampleCount) return;\n\n        this._multisampleCount = multisampleCount;\n\n        this._updatePipeHash();\n    }\n\n    public setRenderTarget(renderTarget: GpuRenderTarget)\n    {\n        this._multisampleCount = renderTarget.msaaSamples;\n        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n\n        this._updatePipeHash();\n    }\n\n    public setColorMask(colorMask: number): void\n    {\n        if (this._colorMask === colorMask) return;\n\n        this._colorMask = colorMask;\n\n        this._updatePipeHash();\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES): void\n    {\n        if (this._stencilMode === stencilMode) return;\n\n        this._stencilMode = stencilMode;\n        this._stencilState = GpuStencilModesToPixi[stencilMode];\n\n        this._updatePipeHash();\n    }\n\n    public setPipeline(geometry: Geometry, program: GpuProgram, state: State, passEncoder: GPURenderPassEncoder): void\n    {\n        const pipeline = this.getPipeline(geometry, program, state);\n\n        passEncoder.setPipeline(pipeline);\n    }\n\n    public getPipeline(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: State,\n        topology?: Topology,\n    ): GPURenderPipeline\n    {\n        if (!geometry._layoutKey)\n        {\n            ensureAttributes(geometry, program.attributeData);\n\n            // prepare the geometry for the pipeline\n            this._generateBufferKey(geometry);\n        }\n\n        topology = topology || geometry.topology;\n\n        // now we have set the Ids - the key is different...\n        // eslint-disable-next-line max-len\n        const key = getGraphicsStateKey(\n            geometry._layoutKey,\n            program._layoutKey,\n            state.data,\n            state._blendModeId,\n            topologyStringToId[topology],\n        );\n\n        if (this._pipeCache[key]) return this._pipeCache[key];\n\n        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n\n        return this._pipeCache[key];\n    }\n\n    private _createPipeline(geometry: Geometry, program: GpuProgram, state: State, topology: Topology): GPURenderPipeline\n    {\n        const device = this._gpu.device;\n\n        const buffers = this._createVertexBufferLayouts(geometry);\n\n        const blendModes = this._renderer.state.getColorTargets(state);\n\n        blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n\n        const layout = this._renderer.shader.getProgramData(program).pipeline;\n\n        const descriptor: GPURenderPipelineDescriptor = {\n            // TODO later check if its helpful to create..\n            // layout,\n            vertex: {\n                module: this._getModule(program.vertex.source),\n                entryPoint: program.vertex.entryPoint,\n                // geometry..\n                buffers,\n            },\n            fragment: {\n                module: this._getModule(program.fragment.source),\n                entryPoint: program.fragment.entryPoint,\n                targets: blendModes,\n            },\n            primitive: {\n                topology,\n                cullMode: state.cullMode,\n            },\n            layout,\n            multisample: {\n                count: this._multisampleCount,\n            },\n            // depthStencil,\n            label: `PIXI Pipeline`,\n        };\n\n        // only apply if the texture has stencil or depth\n        if (this._depthStencilAttachment)\n        {\n            // mask states..\n            descriptor.depthStencil = {\n                ...this._stencilState,\n                format: 'depth24plus-stencil8',\n                depthWriteEnabled: state.depthTest,\n                depthCompare: state.depthTest ? 'less' : 'always',\n            };\n        }\n\n        const pipeline = device.createRenderPipeline(descriptor);\n\n        return pipeline;\n    }\n\n    private _getModule(code: string): GPUShaderModule\n    {\n        return this._moduleCache[code] || this._createModule(code);\n    }\n\n    private _createModule(code: string): GPUShaderModule\n    {\n        const device = this._gpu.device;\n\n        this._moduleCache[code] = device.createShaderModule({\n            code,\n        });\n\n        return this._moduleCache[code];\n    }\n\n    private _generateBufferKey(geometry: Geometry): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(geometry.attributes).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = geometry.attributes[attributeKeys[i]];\n\n            keyGen[index++] = attribute.location;\n            keyGen[index++] = attribute.offset;\n            keyGen[index++] = attribute.format;\n            keyGen[index++] = attribute.stride;\n        }\n\n        const stringKey = keyGen.join('');\n\n        geometry._layoutKey = createIdFromString(stringKey, 'geometry');\n\n        return geometry._layoutKey;\n    }\n\n    private _createVertexBufferLayouts(geometry: Geometry): GPUVertexBufferLayout[]\n    {\n        if (this._bufferLayoutsCache[geometry._layoutKey])\n        {\n            return this._bufferLayoutsCache[geometry._layoutKey];\n        }\n\n        const vertexBuffersLayout: GPUVertexBufferLayout[] = [];\n\n        geometry.buffers.forEach((buffer) =>\n        {\n            const bufferEntry: GPUVertexBufferLayout = {\n                arrayStride: 0,\n                stepMode: 'vertex',\n                attributes: [],\n            };\n\n            const bufferEntryAttributes = bufferEntry.attributes as GPUVertexAttribute[];\n\n            for (const i in geometry.attributes)\n            {\n                const attribute = geometry.attributes[i];\n\n                if (attribute.buffer === buffer)\n                {\n                    bufferEntry.arrayStride = attribute.stride;\n                    bufferEntry.stepMode = attribute.instance ? 'instance' : 'vertex';\n\n                    bufferEntryAttributes.push({\n                        shaderLocation: attribute.location,\n                        offset: attribute.offset,\n                        format: attribute.format,\n                    });\n                }\n            }\n\n            if (bufferEntryAttributes.length)\n            {\n                vertexBuffersLayout.push(bufferEntry);\n            }\n        });\n\n        this._bufferLayoutsCache[geometry._layoutKey] = vertexBuffersLayout;\n\n        return vertexBuffersLayout;\n    }\n\n    private _updatePipeHash(): void\n    {\n        const key = getGlobalStateKey(\n            this._stencilMode,\n            this._multisampleCount,\n            this._colorMask,\n            this._depthStencilAttachment\n        );\n\n        if (!this._pipeStateCaches[key])\n        {\n            this._pipeStateCaches[key] = Object.create(null);\n        }\n\n        this._pipeCache = this._pipeStateCaches[key];\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        this._bufferLayoutsCache = null;\n    }\n}\n"],"sourceRoot":""}