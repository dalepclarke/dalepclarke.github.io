{"version":3,"sources":["webpack:///../../../../src/rendering/mask/stencil/StencilMaskPipe.ts","webpack:///../../../../../src/rendering/renderers/shared/startup/HelloSystem.ts","webpack:///../../../../../../src/rendering/renderers/shared/shader/utils/uniformParsers.ts","webpack:///../../../../src/scene/container/utils/collectRenderGroups.ts","webpack:///../../src/filters/Filter.ts","webpack:///../../../../src/scene/container/utils/mixColors.ts","webpack:///../../../../src/scene/container/utils/updateRenderGroupTransforms.ts","webpack:///../../../../../src/rendering/renderers/shared/system/SharedSystems.ts","webpack:///../../../../../src/rendering/renderers/shared/view/ViewSystem.ts","webpack:///../../../../../src/rendering/renderers/shared/background/BackgroundSystem.ts","webpack:///../../../../src/rendering/batcher/shared/BatcherPipe.ts","webpack:///../../../../src/scene/container/utils/executeInstructions.ts","webpack:///../../../../../src/rendering/renderers/shared/texture/RenderTexture.ts","webpack:///../../../../../src/rendering/renderers/shared/extract/GenerateTextureSystem.ts","webpack:///../../../../../src/rendering/renderers/shared/renderTarget/isRenderingToScreen.ts","webpack:///../../../../../../src/rendering/renderers/shared/shader/utils/createUboSyncFunction.ts","webpack:///../../../../../src/rendering/renderers/shared/buffer/BufferResource.ts","webpack:///../../../../src/scene/container/utils/mixHexColors.ts","webpack:///../../../../src/scene/container/utils/buildInstructions.ts","webpack:///../../../../src/rendering/mask/alpha/AlphaMaskPipe.ts","webpack:///../../../../src/scene/container/utils/validateRenderables.ts","webpack:///../../src/utils/sayHello.ts","webpack:///../../../src/scene/container/CustomRenderPipe.ts","webpack:///../../../src/scene/container/RenderGroupSystem.ts","webpack:///../../../../src/rendering/mask/color/ColorMaskPipe.ts","webpack:///../../../../../src/rendering/renderers/gpu/state/GpuStencilModesToPixi.ts","webpack:///../../../../../src/rendering/renderers/gpu/renderTarget/calculateProjection.ts","webpack:///../../../src/scene/sprite/SpritePipe.ts","webpack:///../../../../../../src/rendering/renderers/gl/shader/program/ensureAttributes.ts","webpack:///../../../../src/rendering/high-shader/shader-bits/textureBit.ts","webpack:///../../../../../src/rendering/renderers/shared/texture/TextureGCSystem.ts","webpack:///../../../src/scene/container/RenderGroupPipe.ts","webpack:///../../../src/filters/mask/MaskFilter.ts","webpack:///../../../../../src/rendering/renderers/shared/renderTarget/RenderTargetSystem.ts","webpack:///../../../../../src/rendering/renderers/shared/renderTarget/RenderTarget.ts","webpack:///../../../../../../src/rendering/renderers/shared/shader/utils/uboSyncFunctions.ts","webpack:///../../../../../src/rendering/renderers/shared/extract/ExtractSystem.ts","webpack:///../../../../../src/rendering/renderers/shared/blendModes/BlendModePipe.ts","webpack:///../../../../../src/rendering/renderers/shared/renderTarget/GlobalUniformSystem.ts","webpack:///../../../../../src/rendering/renderers/shared/shader/UboSystem.ts","webpack:///../../../../../../src/rendering/renderers/shared/texture/utils/getCanvasTexture.ts"],"names":["StencilMaskPipe","constructor","renderer","_maskStackHash","_maskHash","WeakMap","this","_renderer","push","mask","_container","instructionSet","_a$renderTargetUid","_a","effect","renderPipes","batch","break","blendMode","setBlendMode","add","renderPipeId","action","canBundle","maskContainer","includeInBuild","has","set","instructionsStart","instructionsLength","maskData","get","instructionSize","collectAllRenderables","renderTargetUid","renderTarget","uid","pop","i","instructions","execute","instruction","_a$renderTargetUid2","maskStackIndex","ensureDepthStencil","stencil","setStencilMode","STENCIL_MODES","RENDERING_MASK_ADD","colorMask","setMask","MASK_ACTIVE","RENDERING_MASK_REMOVE","clear","CLEAR","STENCIL","DISABLED","destroy","extension","type","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","name","HelloSystem","init","options","hello","RendererType","WEBGL","context","webGLVersion","sayHello","WebGLSystem","WebGPUSystem","CanvasSystem","priority","defaultOptions","uniformParsers","test","data","value","a","ubo","uniform","size","width","x","red","collectRenderGroups","renderGroup","out","arguments","length","undefined","renderGroupChildren","_Filter","Shader","super","enabled","_state","State","for2d","padding","antialias","resolution","blendRequired","addResource","apply","filterManager","input","output","clearMode","applyFilter","gpu","gl","rest","gpuProgram","glProgram","GpuProgram","from","GlProgram","Filter","WHITE_BGR","mixColors","localBGRColor","parentBGRColor","mixHexColors","tempContainer","Container","updateRenderGroupTransforms","updateChildRenderGroups","updateRenderGroupTransform","childrenToUpdate","updateTick","j","childrenAtDepth","list","index","updateTransformAndChildren","root","worldAlpha","renderGroupParent","worldTransform","appendFrom","relativeGroupTransform","worldColor","groupColor","groupAlpha","copyFrom","localTransform","localColor","localAlpha","worldColorAlpha","container","updateFlags","didChange","updateLocalTransform","parent","isRenderGroupRoot","_updateFlags","updateColorBlendVisibility","children","structureDidChange","updateRenderable","UPDATE_COLOR","groupColorAlpha","UPDATE_BLEND","groupBlendMode","localBlendMode","UPDATE_VISIBLE","globalDisplayStatus","localDisplayStatus","SharedSystems","BackgroundSystem","GlobalUniformSystem","ViewSystem","RenderGroupSystem","TextureGCSystem","GenerateTextureSystem","ExtractSystem","SharedRenderPipes","BlendModePipe","BatcherPipe","SpritePipe","RenderGroupPipe","AlphaMaskPipe","ColorMaskPipe","CustomRenderPipe","_ViewSystem","texture","source","_resolution","resize","height","view","deprecation","v8_0_0","canvas","screen","Rectangle","DOMAdapter","createCanvas","getCanvasTexture","RenderTarget","colorTextures","depth","isRoot","transparent","backgroundAlpha","multiView","autoDensity","style","desiredScreenWidth","desiredScreenHeight","frame","removeView","parentNode","removeChild","_BackgroundSystem","clearBeforeRender","_backgroundColor","Color","color","alpha","background","backgroundColor","setAlpha","setValue","toArray","adaptor","state","_batches","Object","create","_geometries","_adaptor","buildStart","batcher","Batcher","BatchGeometry","_activeBatch","_activeGeometry","begin","addToBatch","batchableObject","buildEnd","activeBatch","geometry","finish","indexBuffer","setDataWithSize","indexSize","buffers","attributeBuffer","float32View","attributeSize","upload","dirty","update","start","executeInstructions","RenderTexture","Texture","TextureSource","tempRect","tempBounds","Bounds","noColor","generateTexture","_options$frame","target","textureSourceOptions","clearColor","isRGBAArray","Array","isArray","shared","region","copyTo","getLocalBounds","rectangle","Math","max","transform","Matrix","translate","y","render","isRenderingToScreen","resource","colorTexture","globalThis","HTMLCanvasElement","document","body","contains","createUboSyncFunction","uboElements","parserCode","arrayGenerationFunction","singleSettersMap","funcFragments","prev","uboElement","parsed","offset","uniformParser","template","fragmentSrc","join","Function","BufferResource","EventEmitter","_ref","buffer","_resourceType","_touched","_resourceId","_bufferResource","destroyed","on","onBufferChange","emit","destroyBuffer","color1","color2","ratio","r1","g1","b1","r2","g2","b2","r","g","b","buildInstructions","reset","sortableChildren","sortChildren","collectAllRenderablesAdvanced","rendererPipes","isSimple","collectAllRenderablesSimple","didViewUpdate","rp","addRenderable","addRenderGroup","effects","pipe","AlphaMaskEffect","FilterEffect","filters","MaskFilter","sprite","Sprite","EMPTY","_activeMaskStage","maskedContainer","renderMaskToTexture","_maskedContainer","renderMask","filterEffect","BigPool","measurable","bounds","getGlobalBounds","ceil","filterTexture","TexturePool","getOptimalTexture","globalUniforms","tx","minX","ty","minY","filter","returnTexture","return","validateRenderables","childrenRenderablesToUpdate","rebuildRequired","renderable","validateRenderable","saidHello","VERSION","getNavigator","userAgent","toLowerCase","indexOf","args","console","log","isRenderable","tempMatrix","isRenderGroup","renderGroups","originalLocalTransform","runOnRender","updateRenderables","worldTransformMatrix","uniformBatch","renderEnd","_colorStack","_colorStackIndex","_currentColor","colorStack","currentColor","_mask","GpuStencilModesToPixi","NONE","stencilWriteMask","stencilReadMask","stencilFront","compare","passOp","stencilBack","calculateProjection","pm","flipY","sign","identity","d","_gpuSpriteHash","_instructionSet","gpuSprite","_getGpuSprite","_didSpriteUpdate","_updateBatchableSprite","updateElement","_texture","_source","checkAndUpdateTexture","destroyRenderable","batchableSprite","_initGPUSprite","BatchableSprite","roundPixels","_roundPixels","ensureAttributes","extractedData","attributes","attribute","attributeData","_attribute$location","_attribute$format","_attribute$offset","_attribute$instance","location","format","instance","warn","ensureStartAndStride","tempStride","tempStart","getAttributeInfoFromFormat","stride","_attribute$stride","_attribute$start","textureBit","vertex","header","main","fragment","textureBitGl","_TextureGCSystem","count","checkCount","checkCountMax","textureGCCheckCountMax","maxIdle","textureGCAMaxIdle","active","textureGCActive","postrender","renderingToScreen","run","managedTextures","autoGarbageCollect","unload","extensions","textureMatrix","TextureMatrix","filterUniforms","UniformGroup","uFilterMatrix","uMaskClamp","uClampFrame","uAlpha","entryPoint","resources","uMaskTexture","_textureMatrix","calculateSpriteMatrix","uniforms","prepend","mapCoord","RenderTargetSystem","rootViewPort","viewport","onRenderTargetChange","SystemRunner","projectionMatrix","defaultClearColor","_renderSurfaceToRenderTargetHash","Map","_gpuRenderTargetHash","_renderTargetStack","finishRenderPass","renderStart","rootRenderTarget","bind","renderSurface","getRenderTarget","gpuRenderTarget","getGpuRenderTarget","pixelWidth","pixelHeight","resizeGpuRenderTarget","startRenderPass","ALL","contextChange","currentRenderTargetData","_this$_renderSurfaceT","isTexture","_initRenderTarget","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","min","forEach","key","CanvasSource","once","destroyGpuRenderTarget","initGpuRenderTarget","_RenderTarget","descriptor","dirtyId","_size","Float32Array","_managedColorTextures","map","colorSource","onSourceResize","depthStencilTexture","ensureDepthStencilTexture","autoGenerateMipmaps","mipLevelCount","skipColorTexture","off","loopMatrix","col","row","total","uboSyncFunctionsSTD40","f32","i32","uboSyncFunctionsWGSL","imageTypes","png","jpg","webp","_ExtractSystem","_normalizeOptions","defaults","image","Image","src","base64","defaultImageOptions","quality","toBlob","Promise","resolve","reject","blob","Error","reader","FileReader","onload","result","onerror","readAsDataURL","toDataURL","convertToBlob","generateCanvas","textureGenerator","pixels","pixelInfo","getPixels","download","_options$filename","link","createElement","filename","href","appendChild","click","_options$width","BLEND_MODE_FILTERS","handle","BlendMode","ref","_isAdvanced","_filterHash","_activeBlendMode","_endAdvancedBlendMode","_beginAdvancedBlendMode","_renderableList","renderables","_stackIndex","_globalUniformDataStack","_uniformsPool","_activeUniforms","_bindGroupPool","_activeBindGroups","currentGlobalUniformData","projectionData","Point","globalUniformData","bindGroup","uniformGroup","_createUniforms","uProjectionMatrix","uResolution","uWorldTransformMatrix","color32BitToUniform","uWorldColorAlpha","getUniformBindGroup","BindGroup","setResource","_currentGlobalUniformData","isStatic","UboSystem","_syncFunctionHash","_systemCheck","unsafeEvalSupported","ensureUniformGroup","uniformData","getUniformGroupData","Buffer","layout","usage","BufferUsage","UNIFORM","COPY_DST","_signature","_initUniformGroup","uniformGroupSignature","elements","keys","uniformStructures","createUboElements","syncFunction","_generateUboSync","generateUboSync","syncUniformGroup","uniformGroupData","updateUniformGroup","_dirtyId","synced","canvasCache","onDestroy","delete"],"mappings":"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","file":"js/chunk-473846b0.096e2d85.js","sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions';\nimport { CLEAR } from '../../renderers/gl/const';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMask } from './StencilMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nexport interface StencilMaskInstruction extends Instruction\n{\n    renderPipeId: 'stencilMask',\n    action: MaskMode,\n    mask: StencilMask,\n}\n\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n\n    // used when building and also when executing..\n    private _maskStackHash: Record<number, number> = {};\n\n    private _maskHash = new WeakMap<StencilMask, {\n        instructionsStart: number,\n        instructionsLength: number,\n    }>();\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskContainer = effect.mask;\n\n        maskContainer.includeInBuild = true;\n\n        if (!this._maskHash.has(effect))\n        {\n            this._maskHash.set(effect, {\n                instructionsStart: 0,\n                instructionsLength: 0,\n            });\n        }\n\n        const maskData = this._maskHash.get(effect);\n\n        maskData.instructionsStart = instructionSet.instructionSize;\n\n        collectAllRenderables(\n            maskContainer,\n            instructionSet,\n            renderer.renderPipes,\n        );\n\n        maskContainer.includeInBuild = false;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskEnd',\n            mask,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n\n        maskData.instructionsLength = instructionsLength;\n\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        this._maskStackHash[renderTargetUid] ??= 0;\n    }\n\n    public pop(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        // stencil is stored based on current render target..\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskBegin',\n            canBundle: false,\n        });\n\n        const maskData = this._maskHash.get(mask as StencilMask);\n\n        for (let i = 0; i < maskData.instructionsLength; i++)\n        {\n            // eslint-disable-next-line max-len\n            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        }\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        let maskStackIndex = this._maskStackHash[renderTargetUid] ??= 0;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            // we create the depth and stencil buffers JIT\n            // as no point allocating the memory if we don't use it\n            renderer.renderTarget.ensureDepthStencil();\n\n            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n\n            maskStackIndex++;\n\n            renderer.colorMask.setMask(0);\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            renderer.colorMask.setMask(0xF);\n        }\n        else if (instruction.action === 'popMaskBegin')\n        {\n            renderer.colorMask.setMask(0);\n\n            if (maskStackIndex !== 0)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.renderTarget.clear(null, CLEAR.STENCIL);\n                renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n            }\n\n            maskStackIndex--;\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n\n            renderer.colorMask.setMask(0xF);\n        }\n\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { sayHello } from '../../../../utils/sayHello';\nimport { type Renderer, RendererType } from '../../types';\n\nimport type { WebGLRenderer } from '../../gl/WebGLRenderer';\nimport type { System } from '../system/System';\n\n/**\n * Options for the startup system.\n * @property {boolean} [hello=false] - Whether to log the version and type information of renderer to console.\n * @memberof rendering\n */\nexport interface HelloSystemOptions\n{\n    /**\n     * Whether to log the version and type information of renderer to console.\n     * @memberof rendering.SharedRendererOptions\n     * @default false\n     */\n    hello: boolean;\n}\n\n/**\n * A simple system responsible for initiating the renderer.\n * @memberof rendering\n */\nexport class HelloSystem implements System<HelloSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'hello',\n        priority: -2,\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: HelloSystemOptions = {\n        /** {@link WebGLOptions.hello} */\n        hello: false,\n    };\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * It all starts here! This initiates every system, passing in the options for any system by name.\n     * @param options - the config for the renderer and all its systems\n     */\n    public init(options: HelloSystemOptions): void\n    {\n        if (options.hello)\n        {\n            let name = this._renderer.name;\n\n            if (this._renderer.type === RendererType.WEBGL)\n            {\n                name += ` ${(this._renderer as WebGLRenderer).context.webGLVersion}`;\n            }\n\n            sayHello(name);\n        }\n    }\n}\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n// Parsers, each one of these will take a look at the type of shader property and uniform.\n// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.\n// Shader upload code is automagically generated with these parsers.\n// If no parser is valid then the default upload functions are used.\n// exposing Parsers means that custom upload logic can be added to pixi's shaders.\n// A good example would be a pixi rectangle can be directly set on a uniform.\n// If the shader sees it it knows how to upload the rectangle structure as a vec4\n// format is as follows:\n//\n// {\n//     test: (data, uniform) => {} <--- test is this code should be used for this uniform\n//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform\n//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the\n//                                         uniform to a uniform buffer\n// }\n// import { Texture } from '../../texture/Texture';\n\nimport type { Color } from '../../../../../color/Color';\nimport type { Matrix } from '../../../../../maths/matrix/Matrix';\nimport type { PointLike } from '../../../../../maths/point/PointLike';\nimport type { Rectangle } from '../../../../../maths/shapes/Rectangle';\nimport type { UNIFORM_TYPES, UniformData } from '../types';\n\ninterface UniformParserDefinition\n{\n    type: UNIFORM_TYPES;\n    test(data: UniformData): boolean;\n    ubo?: string;\n    uboWgsl?: string;\n    uboStd40?: string;\n    uniform?: string;\n}\n\nexport const uniformParsers: UniformParserDefinition[] = [\n    // uploading pixi matrix object to mat3\n    {\n        type: 'mat3x3<f32>',\n        test: (data: UniformData): boolean =>\n        {\n            const value = data.value as Matrix;\n\n            return value.a !== undefined;\n        },\n        ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n        uniform: ` \n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n    },\n    // uploading a pixi rectangle as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Rectangle).width !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n    },\n    // uploading a pixi point as a vec2\n    {\n        type: 'vec2<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec2<f32>' && data.size === 1 && (data.value as PointLike).x !== undefined,\n        ubo:  `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n    },\n    // uploading a pixi color as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n    },\n    // uploading a pixi color as a vec3\n    {\n        type: 'vec3<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec3<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n    },\n];\n","import type { RenderGroup } from '../RenderGroup';\n\nexport function collectRenderGroups(renderGroup: RenderGroup, out: RenderGroup[] = [])\n{\n    out.push(renderGroup);\n\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n    {\n        collectRenderGroups(renderGroup.renderGroupChildren[i], out);\n    }\n\n    return out;\n}\n","import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader';\nimport { State } from '../rendering/renderers/shared/state/State';\n\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type {\n    IShaderWithResources,\n    ShaderFromResources,\n    ShaderWithResources\n} from '../rendering/renderers/shared/shader/Shader';\nimport type { BLEND_MODES } from '../rendering/renderers/shared/state/const';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { FilterSystem } from './FilterSystem';\n\n/**\n * Filters provide additional shading and post-processing effects to any display object and its children\n * they are attached to.\n *\n * You attached filters to a display object using its `filters` array property.\n *\n * ```js\n * import { Sprite, BlurFilter, HardMixBlend } from 'pixi.js';\n *\n * const sprite = Sprite.from('myTexture.png');\n *\n * // single filter\n * sprite.filters = new BlurFilter({ strength: 8 });\n *\n * // or multiple filters\n * sprite.filters = [new BlurFilter({ strength: 8 }), new HardMixBlend()];\n * ```\n *\n * Pixi has a number of built-in filters which can be used in your game or application:\n *\n * - {@link filters.AlphaFilter} - Applies alpha to the display object and any of its children.\n * - {@link filters.BlurFilter} - Applies a Gaussian blur to the display object.\n * - {@link filters.BlurFilterPass} - Applies a blur pass to an object.\n * - {@link filters.ColorBurnBlend} - Blend mode to add color burn to display objects.\n * - {@link filters.ColorDodgeBlend} - Blend mode to add color dodge to display objects.\n * - {@link filters.ColorMatrixFilter} - Transform the color channels by matrix multiplication.\n * - {@link filters.DarkenBlend} - Blend mode to darken display objects.\n * - {@link filters.DisplacementFilter} - Applies a displacement map to distort an object.\n * - {@link filters.DivideBlend} - Blend mode to divide display objects.\n * - {@link filters.HardMixBlend} - Blend mode to hard mix display objects.\n * - {@link filters.LinearBurnBlend} - Blend mode to add linear burn to display objects.\n * - {@link filters.LinearDodgeBlend} - Blend mode to add linear dodge to display objects.\n * - {@link filters.LinearLightBlend} - Blend mode to add linear light to display objects.\n * - {@link filters.NoiseFilter} - Applies random noise to an object.\n * - {@link filters.PinLightBlend} - Blend mode to add pin light to display objects.\n * - {@link filters.SubtractBlend} - Blend mode to subtract display objects.\n *\n * <br/>\n * For more available filters, check out the\n *  {@link https://pixijs.io/filters/docs/ pixi-filters} repository.\n *\n * You can also check out the awesome {@link https://pixijs.io/filters/examples/ Filter demo} to see\n * filters in action and combine them!\n * @namespace filters\n */\n\n/**\n * The options to use when creating a new filter.\n * @memberof filters\n */\nexport interface FilterOptions\n{\n    /** optional blend mode used by the filter when rendering (defaults to 'normal') */\n    blendMode?: BLEND_MODES;\n    /**\n     * the resolution the filter should be rendered at. The lower the resolution, the more performant\n     * the filter will be, but the lower the quality of the output. (defaults to the renderers resolution)\n     * Consider lowering this for things like blurs filters\n     */\n    resolution?: number;\n    /**\n     * the amount of pixels to pad the container with when applying the filter. For example a blur extends the\n     * container out as it blurs, so padding is applied to ensure that extra detail is rendered as well\n     * without clipping occurring. (default 0)\n     */\n    padding?: number;\n    /**\n     * If true the filter will make use of antialiasing. Although it looks better this can have a performance impact.\n     * By default, the filter will detect the antialiasing of the renderer and change this automatically.\n     * Definitely don't set this to true if the renderer has antialiasing set to false. As it will antialias,\n     * but you won't see the difference.\n     *\n     * This can be a boolean or [FilterAntialias]{@link filters.FilterAntialias} string.\n     */\n    antialias?: FilterAntialias | boolean;\n    /**\n     * If this is set to true, the filter system will grab a snap shot oif the are being rendered\n     * to and pass this into the shader. This is useful for blend modes that need to be aware of the pixels\n     * they are rendering to. Only use if you need that data, otherwise its an extra gpu copy you don't need!\n     * (default false)\n     */\n    blendRequired?: boolean;\n}\n\n/** Filter options mixed with shader resources. A filter needs a shader and some resources to work. */\nexport type FilterWithShader = FilterOptions & IShaderWithResources;\n\n/**\n * The antialiasing mode of the filter. This can be either:\n * - `on` - the filter is always antialiased regardless of the renderer settings\n * - `off` - the filter is never antialiased regardless of the renderer settings\n * - `inherit` - (default) the filter uses the antialias settings of the renderer\n * @memberof filters\n */\nexport type FilterAntialias = 'on' | 'off' | 'inherit';\n\n/**\n * The Filter class is the base for all filter effects used in Pixi.js\n * As it extends a shader, it requires that a glProgram is parsed in to work with WebGL and a gpuProgram for WebGPU.\n * If you don't proved one, then the filter is skipped and just rendered as if it wasn't there for that renderer.\n *\n * A filter can be applied to anything that extends Container in Pixi.js which also includes Sprites, Graphics etc.\n *\n * Its worth noting Performance-wise filters can be pretty expensive if used too much in a single scene.\n * The following happens under the hood when a filter is applied:\n *\n * .1. Break the current batch\n * <br>\n * .2. The target is measured using getGlobalBounds\n * (recursively go through all children and figure out how big the object is)\n * <br>\n * .3. Get the closest Po2 Textures from the texture pool\n * <br>\n * .4. Render the target to that texture\n * <br>\n * .5. Render that texture back to the main frame buffer as a quad using the filters program.\n * <br>\n * <br>\n * Some filters (such as blur) require multiple passes too which can result in an even bigger performance hit. So be careful!\n * Its not generally the complexity of the shader that is the bottle neck,\n * but all the framebuffer / shader switching that has to take place.\n * One filter applied to a container with many objects is MUCH faster than many filter applied to many objects.\n * @class\n * @memberof filters\n */\nexport class Filter extends Shader\n{\n    /**\n     * The default filter settings\n     * @static\n     */\n    public static readonly defaultOptions: FilterOptions = {\n        blendMode: 'normal',\n        resolution: 1,\n        padding: 0,\n        antialias: 'off',\n        blendRequired: false,\n    };\n\n    /**\n     * The padding of the filter. Some filters require extra space to breath such as a blur.\n     * Increasing this will add extra width and height to the bounds of the object that the\n     * filter is applied to.\n     * @default 0\n     */\n    public padding: number;\n\n    /**\n     * should the filter use antialiasing?\n     * @default inherit\n     */\n    public antialias: FilterAntialias;\n\n    /** If enabled is true the filter is applied, if false it will not. */\n    public enabled = true;\n\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    public _state = State.for2d();\n\n    /**\n     * The resolution of the filter. Setting this to be lower will lower the quality but\n     * increase the performance of the filter.\n     * @default 1\n     */\n    public resolution: number;\n\n    /**\n     * Whether or not this filter requires the previous render texture for blending.\n     * @default false\n     */\n    public blendRequired: boolean;\n\n    /**\n     * @param options - The optional parameters of this filter.\n     */\n    constructor(options: FilterWithShader)\n    {\n        options = { ...Filter.defaultOptions, ...options };\n\n        super(options as ShaderWithResources);\n\n        this.padding = options.padding;\n\n        // check if is boolean\n        if (typeof options.antialias === 'boolean')\n        {\n            this.antialias = options.antialias ? 'on' : 'off';\n        }\n        else\n        {\n            this.antialias = options.antialias;\n        }\n\n        this.resolution = options.resolution;\n        this.blendRequired = options.blendRequired;\n\n        this.addResource('uTexture', 0, 1);\n    }\n\n    /**\n     * Applies the filter\n     * @param filterManager - The renderer to retrieve the filter from\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Get the blend mode of the filter.\n     * @default \"normal\"\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._state.blendMode;\n    }\n\n    /** Sets the blend mode of the filter. */\n    set blendMode(value: BLEND_MODES)\n    {\n        this._state.blendMode = value;\n    }\n\n    /**\n     * A short hand function to create a filter based of a vertex and fragment shader src.\n     * @param options\n     * @returns A shiny new PixiJS filter!\n     */\n    public static from(options: FilterOptions & ShaderFromResources): Filter\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Filter({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n","import { mixHexColors } from './mixHexColors';\n\nconst WHITE_BGR = 0xFFFFFF;\n\nexport function mixColors(localBGRColor: number, parentBGRColor: number)\n{\n    if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR)\n    {\n        return localBGRColor + parentBGRColor - WHITE_BGR;\n    }\n\n    return mixHexColors(localBGRColor, parentBGRColor, 0.5);\n}\n\nexport function mixStandardAnd32BitColors(localColorRGB: number, localAlpha: number, parentColor: number)\n{\n    const parentAlpha = ((parentColor >> 24) & 0xFF) / 255;\n\n    const globalAlpha = ((localAlpha * parentAlpha) * 255);\n\n    // flip rgb to bgr\n    const localBGRColor = ((localColorRGB & 0xFF) << 16) + (localColorRGB & 0xFF00) + ((localColorRGB >> 16) & 0xFF);\n\n    const parentBGRColor = parentColor & 0x00FFFFFF;\n\n    let sharedBGRColor: number;\n\n    if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR)\n    {\n        sharedBGRColor = localBGRColor + parentBGRColor - WHITE_BGR;\n    }\n    else\n    {\n        sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);\n    }\n\n    return sharedBGRColor + (globalAlpha << 24);\n}\n","import { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_VISIBLE } from '../Container';\nimport { mixColors } from './mixColors';\n\nimport type { RenderGroup } from '../RenderGroup';\n\nconst tempContainer = new Container();\n\nexport function updateRenderGroupTransforms(renderGroup: RenderGroup, updateChildRenderGroups = false)\n{\n    updateRenderGroupTransform(renderGroup);\n\n    const childrenToUpdate = renderGroup.childrenToUpdate;\n\n    const updateTick = renderGroup.updateTick;\n\n    renderGroup.updateTick++;\n\n    for (const j in childrenToUpdate)\n    {\n        const childrenAtDepth = childrenToUpdate[j];\n\n        const list = childrenAtDepth.list;\n        const index = childrenAtDepth.index;\n\n        for (let i = 0; i < index; i++)\n        {\n            updateTransformAndChildren(list[i], updateTick, 0);\n        }\n\n        childrenAtDepth.index = 0;\n    }\n\n    if (updateChildRenderGroups)\n    {\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n        }\n    }\n}\n\nexport function updateRenderGroupTransform(renderGroup: RenderGroup)\n{\n    const root = renderGroup.root;\n\n    let worldAlpha;\n\n    if (renderGroup.renderGroupParent)\n    {\n        const renderGroupParent = renderGroup.renderGroupParent;\n\n        renderGroup.worldTransform.appendFrom(\n            root.relativeGroupTransform,\n            renderGroupParent.worldTransform,\n        );\n\n        renderGroup.worldColor = mixColors(\n            root.groupColor,\n            renderGroupParent.worldColor,\n        );\n\n        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n    }\n    else\n    {\n        renderGroup.worldTransform.copyFrom(root.localTransform);\n        renderGroup.worldColor = root.localColor;\n        worldAlpha = root.localAlpha;\n    }\n\n    // eslint-disable-next-line no-nested-ternary\n    worldAlpha = worldAlpha < 0 ? 0 : (worldAlpha > 1 ? 1 : worldAlpha);\n    renderGroup.worldAlpha = worldAlpha;\n\n    renderGroup.worldColorAlpha = renderGroup.worldColor\n            + (((worldAlpha * 255) | 0) << 24);\n}\n\nexport function updateTransformAndChildren(container: Container, updateTick: number, updateFlags: number)\n{\n    if (updateTick === container.updateTick) return;\n    container.updateTick = updateTick;\n\n    container.didChange = false;\n\n    const localTransform = container.localTransform;\n\n    container.updateLocalTransform();\n\n    const parent = container.parent;\n\n    if ((parent && !parent.isRenderGroupRoot))\n    {\n        updateFlags = updateFlags | container._updateFlags;\n\n        container.relativeGroupTransform.appendFrom(\n            localTransform,\n            parent.relativeGroupTransform,\n        );\n\n        if (updateFlags)\n        {\n            updateColorBlendVisibility(container, parent, updateFlags);\n        }\n    }\n    else\n    {\n        updateFlags = container._updateFlags;\n\n        container.relativeGroupTransform.copyFrom(localTransform);\n\n        if (updateFlags)\n        {\n            updateColorBlendVisibility(container, tempContainer, updateFlags);\n        }\n    }\n\n    // don't update children if its a layer..\n    if (!container.isRenderGroupRoot)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            updateTransformAndChildren(children[i], updateTick, updateFlags);\n        }\n\n        const renderGroup = container.renderGroup;\n\n        if (container.renderPipeId && !renderGroup.structureDidChange)\n        {\n            renderGroup.updateRenderable(container);\n        }\n    }\n}\n\nfunction updateColorBlendVisibility(\n    container: Container,\n    parent: Container,\n    updateFlags: number,\n): void\n{\n    if (updateFlags & UPDATE_COLOR)\n    {\n        container.groupColor = mixColors(\n            container.localColor,\n            parent.groupColor\n        );\n\n        let groupAlpha = container.localAlpha * parent.groupAlpha;\n\n        // eslint-disable-next-line no-nested-ternary\n        groupAlpha = groupAlpha < 0 ? 0 : (groupAlpha > 1 ? 1 : groupAlpha);\n\n        container.groupAlpha = groupAlpha;\n        container.groupColorAlpha = container.groupColor + (((groupAlpha * 255) | 0) << 24);\n    }\n\n    if (updateFlags & UPDATE_BLEND)\n    {\n        container.groupBlendMode = container.localBlendMode === 'inherit' ? parent.groupBlendMode : container.localBlendMode;\n    }\n\n    if (updateFlags & UPDATE_VISIBLE)\n    {\n        container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n    }\n\n    container._updateFlags = 0;\n}\n\n","import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe';\nimport { BackgroundSystem } from '../background/BackgroundSystem';\nimport { BlendModePipe } from '../blendModes/BlendModePipe';\nimport { ExtractSystem } from '../extract/ExtractSystem';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem';\nimport { HelloSystem } from '../startup/HelloSystem';\nimport { TextureGCSystem } from '../texture/TextureGCSystem';\nimport { ViewSystem } from '../view/ViewSystem';\n\nimport type { ExtractRendererOptions } from './utils/typeUtils';\n\nexport const SharedSystems = [\n    BackgroundSystem,\n    GlobalUniformSystem,\n    HelloSystem,\n    ViewSystem,\n    RenderGroupSystem,\n    TextureGCSystem,\n    GenerateTextureSystem,\n    ExtractSystem,\n];\n\nexport const SharedRenderPipes = [\n    BlendModePipe,\n    BatcherPipe,\n    SpritePipe,\n    RenderGroupPipe,\n    AlphaMaskPipe,\n    StencilMaskPipe,\n    ColorMaskPipe,\n    CustomRenderPipe\n];\n\n/**\n * Options for the shared systems of a renderer.\n * @memberof rendering\n */\nexport interface SharedRendererOptions extends ExtractRendererOptions<typeof SharedSystems>, PixiMixins.RendererOptions{}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { RenderTarget } from '../renderTarget/RenderTarget';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { System } from '../system/System';\nimport type { CanvasSource, CanvasSourceOptions } from '../texture/sources/CanvasSource';\nimport type { Texture } from '../texture/Texture';\n\n/**\n * Options passed to the ViewSystem\n * @memberof rendering\n * @property {number} [width=800] - The width of the screen.\n * @property {number} [height=600] - The height of the screen.\n * @property {ICanvas} [canvas] - The canvas to use as a view, optional.\n * @property {boolean} [autoDensity=false] - Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n * @property {number} [resolution] - The resolution / device pixel ratio of the renderer.\n * @property {boolean} [antialias=false] - Whether to enable anti-aliasing. This may affect performance.\n * @property {boolean} [depth] -\n * Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer.\n * @property {boolean} [multiView] - TODO: multiView\n * @property {number} [backgroundAlpha] - The alpha of the background.\n */\nexport interface ViewSystemOptions\n{\n    /**\n     * The width of the screen.\n     * @default 800\n     * @memberof rendering.SharedRendererOptions\n     */\n    width?: number;\n    /**\n     * The height of the screen.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    height?: number;\n    /**\n     * The canvas to use as a view, optional.\n     * @memberof rendering.SharedRendererOptions\n     */\n    canvas?: ICanvas;\n    /** @deprecated */\n    view?: ICanvas;\n    /**\n     * Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n     * @memberof rendering.SharedRendererOptions\n     */\n    autoDensity?: boolean;\n    /**\n     * The resolution / device pixel ratio of the renderer.\n     * @memberof rendering.SharedRendererOptions\n     */\n    resolution?: number;\n    /**\n     * Whether to enable anti-aliasing. This may affect performance.\n     * @memberof rendering.SharedRendererOptions\n     */\n    antialias?: boolean;\n    /**\n     * Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer.\n     * @memberof rendering.SharedRendererOptions\n     */\n    depth?: boolean;\n    /**\n     * TODO: multiView\n     * @memberof rendering.SharedRendererOptions\n     */\n    multiView?: boolean;\n\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * @default 1\n     */\n    backgroundAlpha?: number;\n}\n\nexport interface ViewSystemDestroyOptions\n{\n    /** Whether to remove the view element from the DOM. Defaults to `false`. */\n    removeView?: boolean;\n}\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @memberof rendering\n */\nexport class ViewSystem implements System<ViewSystemOptions, TypeOrBool<ViewSystemDestroyOptions>>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'view',\n        priority: 0,\n    } as const;\n\n    /** The default options for the view system. */\n    public static defaultOptions: ViewSystemOptions = {\n        /**\n         * {@link WebGLOptions.width}\n         * @default 800\n         */\n        width: 800,\n        /**\n         * {@link WebGLOptions.height}\n         * @default 600\n         */\n        height: 600,\n        /**\n         * {@link WebGLOptions.autoDensity}\n         * @default false\n         */\n        autoDensity: false,\n        /**\n         * {@link WebGLOptions.antialias}\n         * @default false\n         */\n        antialias: false,\n    };\n\n    public multiView: boolean;\n\n    /** The canvas element that everything is drawn to. */\n    public canvas!: ICanvas;\n\n    /** The texture that is used to draw the canvas to the screen. */\n    public texture: Texture;\n\n    /**\n     * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n     * @member {boolean}\n     */\n    public autoDensity: boolean;\n\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    public antialias: boolean;\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    public screen: Rectangle;\n    /** The render target that the view is drawn to. */\n    public renderTarget: RenderTarget;\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.texture.source._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.texture.source.resize(\n            this.texture.source.width,\n            this.texture.source.height,\n            value\n        );\n    }\n\n    /**\n     * initiates the view system\n     * @param options - the options for the view\n     */\n    public init(options: ViewSystemOptions): void\n    {\n        options = {\n            ...ViewSystem.defaultOptions,\n            ...options,\n        };\n\n        if (options.view)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'ViewSystem.view has been renamed to ViewSystem.canvas');\n            // #endif\n\n            options.canvas = options.view;\n        }\n\n        this.screen = new Rectangle(0, 0, options.width, options.height);\n        this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n        this.antialias = !!options.antialias;\n        this.texture = getCanvasTexture(this.canvas, options as CanvasSourceOptions);\n        this.renderTarget = new RenderTarget({\n            colorTextures: [this.texture],\n            depth: !!options.depth,\n            isRoot: true,\n        });\n\n        (this.texture.source as CanvasSource).transparent = options.backgroundAlpha < 1;\n        this.multiView = !!options.multiView;\n\n        if (this.autoDensity)\n        {\n            this.canvas.style.width = `${this.texture.width}px`;\n            this.canvas.style.height = `${this.texture.height}px`;\n        }\n\n        this.resolution = options.resolution;\n    }\n\n    /**\n     * Resizes the screen and canvas to the specified dimensions.\n     * @param desiredScreenWidth - The new width of the screen.\n     * @param desiredScreenHeight - The new height of the screen.\n     * @param resolution\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution: number): void\n    {\n        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n\n        this.screen.width = this.texture.frame.width;\n        this.screen.height = this.texture.frame.height;\n\n        if (this.autoDensity)\n        {\n            this.canvas.style.width = `${desiredScreenWidth}px`;\n            this.canvas.style.height = `${desiredScreenHeight}px`;\n        }\n    }\n\n    /**\n     * Destroys this System and optionally removes the canvas from the dom.\n     * @param {options | false} options - The options for destroying the view, or \"false\".\n     * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.\n     */\n    public destroy(options: TypeOrBool<ViewSystemDestroyOptions> = false): void\n    {\n        const removeView = typeof options === 'boolean' ? options : !!options?.removeView;\n\n        if (removeView && this.canvas.parentNode)\n        {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n\n        // note: don't nullify the element\n        //       other systems may need to unbind from it during the destroy iteration (eg. GLContextSystem)\n    }\n}\n","import { Color } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { System } from '../system/System';\n\n/**\n * Options for the background system.\n * @property {ColorSource} [backgroundColor='black']\n * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n * @property {ColorSource} [background] - Alias for backgroundColor\n * @property {number} [backgroundAlpha=1] -\n * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n * @property {boolean} [clearBeforeRender=true] - Whether to clear the canvas before new render passes.\n * @memberof rendering\n */\nexport interface BackgroundSystemOptions\n{\n    /**\n     * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n     * @memberof rendering.SharedRendererOptions\n     * @default 'black'\n     */\n    backgroundColor: ColorSource;\n    /**\n     * Alias for backgroundColor\n     * @memberof rendering.SharedRendererOptions\n     */\n    background?: ColorSource\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * @memberof rendering.SharedRendererOptions\n     * @default 1\n     */\n    backgroundAlpha: number;\n    /**\n     * Whether to clear the canvas before new render passes.\n     * @memberof rendering.SharedRendererOptions\n     * @default true\n     */\n    clearBeforeRender: boolean;\n}\n\n/**\n * The background system manages the background color and alpha of the main view.\n * @memberof rendering\n */\nexport class BackgroundSystem implements System<BackgroundSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'background',\n        priority: 0,\n    } as const;\n\n    /** default options used by the system */\n    public static defaultOptions: BackgroundSystemOptions = {\n        /**\n         * {@link WebGLOptions.backgroundAlpha}\n         * @default 1\n         */\n        backgroundAlpha: 1,\n        /**\n         * {@link WebGLOptions.backgroundColor}\n         * @default 0x000000\n         */\n        backgroundColor: 0x0,\n        /**\n         * {@link WebGLOptions.clearBeforeRender}\n         * @default true\n         */\n        clearBeforeRender: true,\n    };\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every\n     * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect\n     * to clear the canvas every frame. Disable this by setting this to false. For example, if\n     * your game has a canvas filling background image you often don't need this set.\n     */\n    public clearBeforeRender: boolean;\n\n    private readonly _backgroundColor: Color;\n\n    constructor()\n    {\n        this.clearBeforeRender = true;\n\n        this._backgroundColor = new Color(0x000000);\n\n        this.color = this._backgroundColor; // run bg color setter\n        this.alpha = 1;\n    }\n\n    /**\n     * initiates the background system\n     * @param options - the options for the background colors\n     */\n    public init(options: BackgroundSystemOptions): void\n    {\n        options = { ...BackgroundSystem.defaultOptions, ...options };\n\n        this.clearBeforeRender = options.clearBeforeRender;\n        this.color = options.background || options.backgroundColor || this._backgroundColor; // run bg color setter\n        this.alpha = options.backgroundAlpha;\n\n        this._backgroundColor.setAlpha(options.backgroundAlpha);\n    }\n\n    /** The background color to fill if not transparent */\n    get color(): Color\n    {\n        return this._backgroundColor;\n    }\n\n    set color(value: ColorSource)\n    {\n        this._backgroundColor.setValue(value);\n    }\n\n    /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n    get alpha(): number\n    {\n        return this._backgroundColor.alpha;\n    }\n\n    set alpha(value: number)\n    {\n        this._backgroundColor.setAlpha(value);\n    }\n\n    /** The background color as an [R, G, B, A] array. */\n    get colorRgba(): RgbaArray\n    {\n        return this._backgroundColor.toArray() as RgbaArray;\n    }\n\n    /**\n     * destroys the background system\n     * @internal\n     * @ignore\n     */\n    public destroy(): void\n    {\n        // No cleanup required\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { BatchGeometry } from '../gpu/BatchGeometry';\nimport { Batcher } from './Batcher';\n\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { Batch, BatchableObject } from './Batcher';\n\nexport interface BatcherAdaptor\n{\n    start(batchPipe: BatcherPipe, geometry: Geometry): void\n    init(batchPipe: BatcherPipe): void;\n    execute(batchPipe: BatcherPipe, batch: Batch): void\n    destroy(): void;\n    contextChange?(): void;\n}\n\n// eslint-disable-next-line max-len\nexport class BatcherPipe implements InstructionPipe<Batch>, BatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'batch',\n    } as const;\n\n    public state: State = State.for2d();\n    public renderer: Renderer;\n\n    private _batches: Record<number, Batcher> = Object.create(null);\n    private _geometries: Record<number, BatchGeometry> = Object.create(null);\n    private _adaptor: BatcherAdaptor;\n\n    private _activeBatch: Batcher;\n    private _activeGeometry: Geometry;\n\n    constructor(renderer: Renderer, adaptor: BatcherAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init(this);\n    }\n\n    public buildStart(instructionSet: InstructionSet)\n    {\n        if (!this._batches[instructionSet.uid])\n        {\n            const batcher = new Batcher();\n\n            this._batches[instructionSet.uid] = batcher;\n            this._geometries[batcher.uid] = new BatchGeometry();\n        }\n\n        this._activeBatch = this._batches[instructionSet.uid];\n        this._activeGeometry = this._geometries[this._activeBatch.uid];\n\n        this._activeBatch.begin();\n    }\n\n    public addToBatch(batchableObject: BatchableObject)\n    {\n        this._activeBatch.add(batchableObject);\n    }\n\n    public break(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n    }\n\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        const activeBatch = this._activeBatch;\n        const geometry = this._activeGeometry;\n\n        activeBatch.finish(instructionSet);\n\n        geometry.indexBuffer.setDataWithSize(activeBatch.indexBuffer, activeBatch.indexSize, true);\n\n        geometry.buffers[0].setDataWithSize(activeBatch.attributeBuffer.float32View, activeBatch.attributeSize, false);\n    }\n\n    public upload(instructionSet: InstructionSet)\n    {\n        const batcher = this._batches[instructionSet.uid];\n        const geometry = this._geometries[batcher.uid];\n\n        if (batcher.dirty)\n        {\n            batcher.dirty = false;\n            geometry.buffers[0].update(batcher.attributeSize * 4);\n        }\n    }\n\n    public execute(batch: Batch)\n    {\n        if (batch.action === 'startBatch')\n        {\n            const batcher = batch.batcher;\n            const geometry = this._geometries[batcher.uid];\n\n            this._adaptor.start(this, geometry);\n        }\n\n        this._adaptor.execute(this, batch);\n    }\n\n    public destroy()\n    {\n        this.state = null;\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        for (const i in this._batches)\n        {\n            this._batches[i].destroy();\n        }\n\n        this._batches = null;\n\n        for (const i in this._geometries)\n        {\n            this._geometries[i].destroy();\n        }\n\n        this._geometries = null;\n    }\n}\n","import type { InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\nexport function executeInstructions(renderGroup: RenderGroup, renderer: RenderPipes)\n{\n    const instructionSet = renderGroup.instructionSet;\n    const instructions = instructionSet.instructions;\n\n    for (let i = 0; i < instructionSet.instructionSize; i++)\n    {\n        const instruction = instructions[i];\n\n        (renderer[instruction.renderPipeId as keyof RenderPipes] as InstructionPipe<any>).execute(instruction);\n    }\n}\n","import { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\n/**\n * A render texture, extends `Texture`.\n * @see {@link rendering.Texture}\n * @memberof rendering\n */\nexport class RenderTexture extends Texture\n{\n    public static create(options: TextureSourceOptions): Texture\n    {\n        return new Texture({\n            source: new TextureSource(options)\n        });\n    }\n\n    /**\n     * Resizes the render texture.\n     * @param width - The new width of the render texture.\n     * @param height - The new height of the render texture.\n     * @param resolution - The new resolution of the render texture.\n     * @returns This texture.\n     */\n    public resize(width: number, height: number, resolution?: number): this\n    {\n        this.source.resize(width, height, resolution);\n\n        return this;\n    }\n}\n","import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\nimport type { Texture } from '../texture/Texture';\n\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * @memberof rendering\n */\nexport type GenerateTextureOptions =\n{\n    /** The container to generate the texture from */\n    target: Container;\n    /**\n     * The region of the container, that shall be rendered,\n     * if no region is specified, defaults to the local bounds of the container.\n     */\n    frame?: Rectangle;\n    /** The resolution of the texture being generated. */\n    resolution?: number;\n    /** The color used to clear the texture. */\n    clearColor?: ColorSource;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n    /** The options passed to the texture source. */\n    textureSourceOptions?: GenerateTextureSourceOptions,\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from the renderer\n *\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.textureGenerator` property.\n * @memberof rendering\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * A Useful function that returns a texture of the display object that can then be used to create sprites\n     * This can be quite useful if your container is complicated and needs to be reused multiple times.\n     * @param {GenerateTextureOptions | Container} options - Generate texture options.\n     * @param {Container} [options.container] - If not given, the renderer's resolution is used.\n     * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n     * @param {number} [options.resolution] - The resolution of the texture being generated.\n     *        if no region is specified, defaults to the local bounds of the container.\n     * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n     * @returns a shiny new texture of the container passed in\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): Texture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import type { RenderTarget } from './RenderTarget';\n\n/**\n * Checks if the render target is viewable on the screen\n * Basically, is it a canvas element and is that canvas element in the DOM\n * @param renderTarget - the render target to check\n * @returns true if the render target is viewable on the screen\n */\nexport function isRenderingToScreen(renderTarget: RenderTarget): boolean\n{\n    const resource = renderTarget.colorTexture.source.resource;\n\n    return ((globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement) && document.body.contains(resource));\n}\n","/* eslint-disable quote-props */\nimport { uniformParsers } from './uniformParsers';\n\nimport type { UboElement, UNIFORM_TYPES_SINGLE, UniformsSyncCallback } from '../types';\n\nexport function createUboSyncFunction(\n    uboElements: UboElement[],\n    parserCode: 'uboWgsl' | 'uboStd40',\n    arrayGenerationFunction: (uboElement: UboElement, offsetToAdd: number) => string,\n    singleSettersMap: Record<UNIFORM_TYPES_SINGLE, string>,\n): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n\n    let prev = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n        let offset = 0;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.test(uboElement.data))\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(\n                    `name = \"${name}\";`,\n                    `offset += ${offset - prev};`,\n                    uniformParsers[j][parserCode] || uniformParsers[j].ubo);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n            }\n            else\n            {\n                const template = singleSettersMap[uboElement.data.type as UNIFORM_TYPES_SINGLE];\n\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(/* wgsl */`\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `);\n            }\n        }\n\n        prev = offset;\n    }\n\n    const fragmentSrc = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function(\n        'uv',\n        'data',\n        'offset',\n        fragmentSrc,\n    ) as UniformsSyncCallback;\n}\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from './Buffer';\n\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @memberof rendering\n */\nexport class BufferResource extends EventEmitter<{\n    change: BindResource,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */\n    public readonly uid = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'bufferResource';\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /** the underlying buffer that this resource is using */\n    public buffer: Buffer;\n    /** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n    public readonly offset: number;\n    /** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n    public readonly size: number;\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     * @ignore\n     */\n    public readonly _bufferResource = true;\n\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Create a new Buffer Resource.\n     * @param options - The options for the buffer resource\n     * @param options.buffer - The underlying buffer that this resource is using\n     * @param options.offset - The offset of the buffer this resource is using.\n     * If not provided, then it will use the offset of the buffer.\n     * @param options.size - The size of the buffer this resource is using.\n     * If not provided, then it will use the size of the buffer.\n     */\n    constructor({ buffer, offset, size }: { buffer: Buffer; offset?: number; size?: number; })\n    {\n        super();\n\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n\n        this.buffer.on('change', this.onBufferChange, this);\n    }\n\n    protected onBufferChange(): void\n    {\n        this._resourceId = uid('resource');\n\n        this.emit('change', this);\n    }\n\n    /**\n     * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n     * if you want to destroy it as well, or code will explode\n     * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n     */\n    public destroy(destroyBuffer = false): void\n    {\n        this.destroyed = true;\n\n        if (destroyBuffer)\n        {\n            this.buffer.destroy();\n        }\n\n        this.emit('change', this);\n\n        this.buffer = null;\n    }\n}\n","export function mixHexColors(color1: number, color2: number, ratio: number): number\n{\n    const r1 = (color1 >> 16) & 0xFF;\n    const g1 = (color1 >> 8) & 0xFF;\n    const b1 = color1 & 0xFF;\n\n    const r2 = (color2 >> 16) & 0xFF;\n    const g2 = (color2 >> 8) & 0xFF;\n    const b2 = color2 & 0xFF;\n\n    const r = r1 + ((r2 - r1) * ratio);\n    const g = g1 + ((g2 - g1) * ratio);\n    const b = b1 + ((b2 - b1) * ratio);\n\n    return (r << 16) + (g << 8) + b;\n}\n\n","import type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { Container } from '../Container';\nimport type { RenderGroup } from '../RenderGroup';\n\nexport function buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes)\n{\n    const root = renderGroup.root;\n    const instructionSet = renderGroup.instructionSet;\n\n    instructionSet.reset();\n\n    // TODO add some events / runners for build start\n    renderPipes.batch.buildStart(instructionSet);\n    renderPipes.blendMode.buildStart();\n    renderPipes.colorMask.buildStart();\n\n    if (root.sortableChildren)\n    {\n        root.sortChildren();\n    }\n\n    collectAllRenderablesAdvanced(root, instructionSet, renderPipes, true);\n\n    // instructionSet.log();\n    // TODO add some events / runners for build end\n    renderPipes.batch.buildEnd(instructionSet);\n    renderPipes.blendMode.buildEnd(instructionSet);\n\n    // instructionSet.log();\n}\n\nexport function collectAllRenderables(\n    container: Container,\n    instructionSet: InstructionSet,\n    rendererPipes: RenderPipes\n): void\n{\n    // if there is 0b01 or 0b10 the return value\n\n    if (container.globalDisplayStatus < 0b111 || !container.includeInBuild) return;\n\n    if (container.sortableChildren)\n    {\n        container.sortChildren();\n    }\n\n    if (container.isSimple)\n    {\n        collectAllRenderablesSimple(container, instructionSet, rendererPipes);\n    }\n    else\n    {\n        collectAllRenderablesAdvanced(container, instructionSet, rendererPipes, false);\n    }\n}\n\nfunction collectAllRenderablesSimple(\n    container: Container,\n    instructionSet: InstructionSet,\n    renderPipes: RenderPipes\n): void\n{\n    if (container.renderPipeId)\n    {\n        // TODO add blends in\n        renderPipes.blendMode.setBlendMode(container as Renderable, container.groupBlendMode, instructionSet);\n\n        container.didViewUpdate = false;\n\n        const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n        rp[container.renderPipeId].addRenderable(container as Renderable, instructionSet);\n    }\n\n    if (!container.isRenderGroupRoot)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            collectAllRenderables(children[i], instructionSet, renderPipes);\n        }\n    }\n}\n\nfunction collectAllRenderablesAdvanced(\n    container: Container,\n    instructionSet: InstructionSet,\n    renderPipes: RenderPipes,\n    isRoot: boolean\n): void\n{\n    if (!isRoot && container.isRenderGroupRoot)\n    {\n        renderPipes.renderGroup.addRenderGroup(container.renderGroup, instructionSet);\n    }\n    else\n    {\n        for (let i = 0; i < container.effects.length; i++)\n        {\n            const effect = container.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes]as InstructionPipe<any>;\n\n            pipe.push(effect, container, instructionSet);\n        }\n\n        const renderPipeId = container.renderPipeId;\n\n        if (renderPipeId)\n        {\n            // TODO add blends in\n            renderPipes.blendMode.setBlendMode(container as Renderable, container.groupBlendMode, instructionSet);\n            container.didViewUpdate = false;\n\n            const pipe = renderPipes[renderPipeId as keyof RenderPipes]as RenderPipe<any>;\n\n            pipe.addRenderable(container, instructionSet);\n        }\n\n        const children = container.children;\n\n        if (children.length)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                collectAllRenderables(children[i], instructionSet, renderPipes);\n            }\n        }\n\n        // loop backwards through effects\n        for (let i = container.effects.length - 1; i >= 0; i--)\n        {\n            const effect = container.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes]as InstructionPipe<any>;\n\n            pipe.pop(effect, container, instructionSet);\n        }\n    }\n}\n\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter';\nimport { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { Renderer } from '../../renderers/types';\nimport type { AlphaMask } from './AlphaMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nconst tempBounds = new Bounds();\n\nclass AlphaMaskEffect extends FilterEffect implements PoolItem\n{\n    constructor()\n    {\n        super({\n            filters: [new MaskFilter({\n                sprite: new Sprite(Texture.EMPTY)\n            })]\n        });\n    }\n\n    get sprite(): Sprite\n    {\n        return (this.filters[0] as MaskFilter).sprite;\n    }\n\n    set sprite(value: Sprite)\n    {\n        (this.filters[0] as MaskFilter).sprite = value;\n    }\n\n    public init: () => void;\n}\n\nexport interface AlphaMaskInstruction extends Instruction\n{\n    renderPipeId: 'alphaMask',\n    action: MaskMode,\n    mask: AlphaMask,\n    maskedContainer: Container,\n    renderMask: boolean,\n}\n\nexport interface AlphaMaskData\n{\n    filterEffect: AlphaMaskEffect,\n    maskedContainer: Container,\n    previousRenderTarget?: RenderTarget,\n    filterTexture?: Texture,\n}\n\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'alphaMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _activeMaskStage: AlphaMaskData[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskBegin',\n            mask,\n            canBundle: false,\n            maskedContainer\n        } as AlphaMaskInstruction);\n\n        if ((mask as AlphaMask).renderMaskToTexture)\n        {\n            const maskContainer = (mask as AlphaMask).mask;\n\n            maskContainer.includeInBuild = true;\n\n            collectAllRenderables(\n                maskContainer,\n                instructionSet,\n                renderer.renderPipes\n            );\n\n            maskContainer.includeInBuild = false;\n        }\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskEnd',\n            mask,\n            maskedContainer,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public pop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'popMaskEnd',\n            mask,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public execute(instruction: AlphaMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const filterEffect = BigPool.get(AlphaMaskEffect);\n\n            if (renderMask)\n            {\n                instruction.mask.mask.measurable = true;\n\n                const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n                instruction.mask.mask.measurable = false;\n\n                bounds.ceil();\n\n                const filterTexture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    1,\n                    false\n                );\n\n                renderer.renderTarget.push(filterTexture, true);\n\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 0xFFFFFFFF\n                });\n\n                const sprite = filterEffect.sprite;\n\n                sprite.texture = filterTexture;\n\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture,\n                });\n            }\n            else\n            {\n                filterEffect.sprite = instruction.mask.mask as Sprite;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                });\n            }\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n\n            if (renderMask)\n            {\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n\n            renderer.filter.push({\n                renderPipeId: 'filter',\n                action: 'pushFilter',\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false,\n            });\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.filter.pop();\n\n            const maskData = this._activeMaskStage.pop();\n\n            if (renderMask)\n            {\n                TexturePool.returnTexture(maskData.filterTexture);\n            }\n\n            BigPool.return(maskData.filterEffect);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n","import type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\nexport function validateRenderables(renderGroup: RenderGroup, renderPipes: RenderPipes): boolean\n{\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n    let rebuildRequired = false;\n\n    for (let i = 0; i < index; i++)\n    {\n        const container = list[i];\n\n        const renderable = container;\n        const pipe = renderPipes[renderable.renderPipeId as keyof RenderPipes] as RenderPipe<any>;\n\n        rebuildRequired = pipe.validateRenderable(container);\n\n        if (rebuildRequired)\n        {\n            break;\n        }\n    }\n\n    renderGroup.structureDidChange = rebuildRequired;\n\n    return rebuildRequired;\n}\n","import { DOMAdapter } from '../environment/adapter';\n\nlet saidHello = false;\n\nexport const VERSION = '$_VERSION';\n\n/**\n * Prints out the version and renderer information for this running instance of PixiJS.\n * @param type - The name of the renderer this instance is using.\n * @returns {void}\n */\nexport function sayHello(type: string): void\n{\n    if (saidHello)\n    {\n        return;\n    }\n\n    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf('chrome') > -1)\n    {\n        const args = [\n            `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\\n\\n`,\n            'background: #E72264; padding:5px 0;',\n            'background: #6CA2EA; padding:5px 0;',\n            'background: #B5D33D; padding:5px 0;',\n            'background: #FED23F; padding:5px 0;',\n            'color: #FFFFFF; background: #E72264; padding:5px 0;',\n            'color: #E72264; background: #FFFFFF; padding:5px 0;',\n        ];\n\n        globalThis.console.log(...args);\n    }\n    else if (globalThis.console)\n    {\n        globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n    }\n\n    saidHello = true;\n}\n","import { ExtensionType } from '../../extensions/Extensions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderContainer } from './RenderContainer';\n\n/**\n * The CustomRenderPipe is a render pipe that allows for custom rendering logic for your renderable objects.\n * @example\n * import { RenderContainer } from 'pixi.js';\n *\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * @memberof rendering\n */\nexport class CustomRenderPipe implements InstructionPipe<RenderContainer>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'customRender',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(container: RenderContainer, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add(container);\n    }\n\n    public execute(container: RenderContainer)\n    {\n        if (!container.isRenderable) return;\n\n        container.render(this._renderer);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { buildInstructions } from './utils/buildInstructions';\nimport { collectRenderGroups } from './utils/collectRenderGroups';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @memberof rendering\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        container.isRenderGroup = true;\n\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        const renderGroups = collectRenderGroups(container.renderGroup, []);\n\n        let originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        for (let i = 0; i < renderGroups.length; i++)\n        {\n            const renderGroup = renderGroups[i];\n\n            renderGroup.runOnRender();\n\n            renderGroup.instructionSet.renderPipes = renderPipes;\n\n            if (!renderGroup.structureDidChange)\n            {\n                // phase 1 - validate all the renderables\n                validateRenderables(renderGroup, renderPipes);\n            }\n\n            // phase 2 - update all the transforms\n            // including updating the renderables..\n            updateRenderGroupTransforms(renderGroup);\n\n            if (renderGroup.structureDidChange)\n            {\n                renderGroup.structureDidChange = false;\n\n                // build the renderables\n                buildInstructions(renderGroup, renderPipes);\n            }\n            else\n            {\n                // update remaining renderables\n                updateRenderables(renderGroup);\n            }\n\n            // reset the renderables to update\n            renderGroup.childrenRenderablesToUpdate.index = 0;\n\n            // upload all the things!\n            renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n        }\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n\nfunction updateRenderables(renderGroup: RenderGroup)\n{\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n    for (let i = 0; i < index; i++)\n    {\n        const container = list[i];\n\n        if (container.didViewUpdate)\n        {\n            renderGroup.updateRenderable(container);\n        }\n    }\n}\n\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { ColorMask } from './ColorMask';\n\nexport interface ColorMaskInstruction extends Instruction\n{\n    renderPipeId: 'colorMask',\n    colorMask: number,\n}\n\nexport class ColorMaskPipe implements InstructionPipe<ColorMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private _colorStack: number[] = [];\n    private _colorStackIndex = 0;\n    private _currentColor = 0;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public buildStart()\n    {\n        this._colorStack[0] = 0xF;\n        this._colorStackIndex = 1;\n        this._currentColor = 0xF;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & (mask as ColorMask).mask;\n\n        const currentColor = this._colorStack[this._colorStackIndex];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n\n        this._colorStackIndex++;\n    }\n\n    public pop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        this._colorStackIndex--;\n\n        const currentColor = colorStack[this._colorStackIndex - 1];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n    }\n\n    public execute(instruction: ColorMaskInstruction)\n    {\n        const renderer = this._renderer;\n\n        renderer.colorMask.setMask(instruction.colorMask);\n    }\n\n    public destroy()\n    {\n        this._colorStack = null;\n    }\n}\n","import { STENCIL_MODES } from '../../shared/state/const';\n\nexport interface StencilState\n{\n    stencilWriteMask?: number\n    stencilReadMask?: number;\n    stencilFront?: {\n        compare: 'always' | 'equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep';\n    },\n    stencilBack?: {\n        compare: 'always' | 'equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep';\n    }\n}\n\nexport const GpuStencilModesToPixi: StencilState[] = [];\n\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = undefined;\n\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n    stencilWriteMask: 0,\n    stencilReadMask: 0,\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n};\n","import type { Matrix } from '../../../../maths/matrix/Matrix';\n\nexport function calculateProjection(\n    pm: Matrix,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    flipY: boolean\n): Matrix\n{\n    const sign = flipY ? 1 : -1;\n\n    pm.identity();\n\n    pm.a = (1 / width * 2);\n    pm.d = sign * (1 / height * 2);\n\n    pm.tx = -1 - (x * pm.a);\n    pm.ty = -sign - (y * pm.d);\n\n    return pm;\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from './BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Sprite } from './Sprite';\n\nexport class SpritePipe implements RenderPipe<Sprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'sprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuSpriteHash: Record<number, BatchableSprite> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: Sprite, _instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        // TODO visibility\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n    }\n\n    public updateRenderable(sprite: Sprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite.batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: Sprite): boolean\n    {\n        const texture = sprite._texture;\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (gpuSprite.texture._source !== texture._source)\n        {\n            return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n        }\n\n        return false;\n    }\n\n    public destroyRenderable(sprite: Sprite)\n    {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableSprite as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n    }\n\n    private _updateBatchableSprite(sprite: Sprite, batchableSprite: BatchableSprite)\n    {\n        sprite._didSpriteUpdate = false;\n        batchableSprite.bounds = sprite.bounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: Sprite): BatchableSprite\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: Sprite): BatchableSprite\n    {\n        const batchableSprite = BigPool.get(BatchableSprite);\n\n        batchableSprite.renderable = sprite;\n\n        batchableSprite.texture = sprite._texture;\n        batchableSprite.bounds = sprite.bounds;\n        batchableSprite.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableSprite;\n\n        sprite._didSpriteUpdate = false;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(sprite);\n        });\n\n        return batchableSprite;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            BigPool.return(this._gpuSpriteHash[i] as PoolItem);\n        }\n\n        this._gpuSpriteHash = null;\n        this._renderer = null;\n    }\n}\n","import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in an gaps. WE do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of th etime users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way, you can\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.location ??= attributeData.location;\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n","export const textureBit = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* wgsl */`\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `,\n        main: /* wgsl */`\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        `,\n        main: /* wgsl */`\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    }\n};\n\nexport const textureBitGl = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureMatrix;\n        `,\n        main: /* glsl */`\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n        uniform sampler2D uTexture;\n\n         \n        `,\n        main: /* glsl */`\n            outColor = texture(uTexture, vUV);\n        `\n    }\n};\n\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\n\n/**\n * Options for the {@link TextureGCSystem}.\n * @memberof rendering\n * @property {boolean} [textureGCActive=true] - If set to true, this will enable the garbage collector on the GPU.\n * @property {number} [textureGCAMaxIdle=60 * 60] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [textureGCCheckCountMax=600] - Frames between two garbage collections.\n */\nexport interface TextureGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCActive: boolean;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCAMaxIdle: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCCheckCountMax: number;\n}\n/**\n * System plugin to the renderer to manage texture garbage collection on the GPU,\n * ensuring that it does not get clogged up with textures that are no longer being used.\n * @memberof rendering\n */\nexport class TextureGCSystem implements System<TextureGCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGC',\n    } as const;\n\n    /** default options for the TextureGCSystem */\n    public static defaultOptions: TextureGCSystemOptions = {\n        /**\n         * If set to true, this will enable the garbage collector on the GPU.\n         * @default true\n         */\n        textureGCActive: true,\n        /**\n         * The maximum idle frames before a texture is destroyed by garbage collection.\n         * @default 60 * 60\n         */\n        textureGCAMaxIdle: 60 * 60,\n        /**\n         * Frames between two garbage collections.\n         * @default 600\n         */\n        textureGCCheckCountMax: 600,\n    };\n\n    /**\n     * Frame count since started.\n     * @readonly\n     */\n    public count: number;\n\n    /**\n     * Frame count since last garbage collection.\n     * @readonly\n     */\n    public checkCount: number;\n\n    /**\n     * Maximum idle frames before a texture is destroyed by garbage collection.\n     * @see TextureGCSystem.defaultMaxIdle\n     */\n    public maxIdle: number;\n\n    /**\n     * Frames between two garbage collections.\n     * @see TextureGCSystem.defaultCheckCountMax\n     */\n    public checkCountMax: number;\n\n    /**\n     * Current garbage collection mode.\n     * @see TextureGCSystem.defaultMode\n     */\n    public active: boolean;\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n\n        this.count = 0;\n        this.checkCount = 0;\n    }\n\n    public init(options: TextureGCSystemOptions): void\n    {\n        options = { ...TextureGCSystem.defaultOptions, ...options };\n\n        this.checkCountMax = options.textureGCCheckCountMax;\n        this.maxIdle = options.textureGCAMaxIdle;\n        this.active = options.textureGCActive;\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    protected postrender(): void\n    {\n        if (!this._renderer.renderingToScreen)\n        {\n            return;\n        }\n\n        this.count++;\n\n        if (!this.active) return;\n\n        this.checkCount++;\n\n        if (this.checkCount > this.checkCountMax)\n        {\n            this.checkCount = 0;\n\n            this.run();\n        }\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    public run(): void\n    {\n        const managedTextures = this._renderer.texture.managedTextures;\n\n        for (let i = 0; i < managedTextures.length; i++)\n        {\n            const texture = managedTextures[i];\n\n            // Only supports non generated textures at the moment!\n            if (\n                texture.autoGarbageCollect\n                && texture.resource\n                && texture._touched > -1\n                && this.count - texture._touched > this.maxIdle\n            )\n            {\n                texture._touched = -1;\n                texture.unload();\n            }\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n\nextensions.add(TextureGCSystem);\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { executeInstructions } from './utils/executeInstructions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderGroup } from './RenderGroup';\n\nexport class RenderGroupPipe implements InstructionPipe<RenderGroup>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderGroup(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add(renderGroup);\n    }\n\n    public execute(renderGroup: RenderGroup)\n    {\n        if (!renderGroup.isRenderable) return;\n\n        this._renderer.globalUniforms.push({\n            worldTransformMatrix: renderGroup.worldTransform,\n            worldColor: renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(renderGroup, this._renderer.renderPipes);\n\n        this._renderer.globalUniforms.pop();\n\n        // now render a quad..\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { Matrix } from '../../maths/matrix/Matrix';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix';\nimport { Filter } from '../Filter';\nimport fragment from './mask.frag';\nimport vertex from './mask.vert';\nimport source from './mask.wgsl';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Sprite } from '../../scene/sprite/Sprite';\nimport type { FilterOptions } from '../Filter';\nimport type { FilterSystem } from '../FilterSystem';\n\nexport interface MaskFilterOptions extends FilterOptions\n{\n    sprite: Sprite,\n    scale?: number | { x: number, y: number },\n}\n\nexport class MaskFilter extends Filter\n{\n    public sprite: Sprite;\n    private readonly _textureMatrix: TextureMatrix;\n\n    constructor(options: MaskFilterOptions)\n    {\n        const { sprite, ...rest } = options;\n\n        const textureMatrix = new TextureMatrix(sprite.texture);\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uMaskClamp: { value: textureMatrix.uClampFrame, type: 'vec4<f32>' },\n            uAlpha: { value: 1, type: 'f32' },\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'mask-filter',\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                filterUniforms,\n                uMaskTexture: sprite.texture.source,\n            },\n        });\n\n        this.sprite = sprite;\n\n        this._textureMatrix = textureMatrix;\n    }\n\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        // will trigger an update if the texture changed..\n        this._textureMatrix.texture = this.sprite.texture;\n\n        filterManager.calculateSpriteMatrix(\n            this.resources.filterUniforms.uniforms.uFilterMatrix as Matrix,\n            this.sprite\n        ).prepend(this._textureMatrix.mapCoord);\n\n        this.resources.uMaskTexture = this.sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { CLEAR } from '../../gl/const';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection';\nimport { SystemRunner } from '../system/SystemRunner';\nimport { CanvasSource } from '../texture/sources/CanvasSource';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\nimport { isRenderingToScreen } from './isRenderingToScreen';\nimport { RenderTarget } from './RenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { GlRenderTarget } from '../../gl/GlRenderTarget';\nimport type { GpuRenderTarget } from '../../gpu/renderTarget/GpuRenderTarget';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * A render surface is a texture, canvas, or render target\n * @memberof rendering\n * @see environment.ICanvas\n * @see rendering.Texture\n * @see rendering.RenderTarget\n */\nexport type RenderSurface = ICanvas | BindableTexture | RenderTarget;\n\n/**\n * stores a render target and its frame\n * @ignore\n */\ninterface RenderTargetAndFrame\n{\n    /** the render target */\n    renderTarget: RenderTarget;\n    /** the frame to use when using the render target */\n    frame: Rectangle\n}\n\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @ignore\n */\nexport interface RenderTargetAdaptor<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget>\n{\n    init(\n        /** the renderer */\n        renderer: Renderer,\n        /** the render target system */\n        renderTargetSystem: RenderTargetSystem<RENDER_TARGET>\n    ): void\n\n    /** A function copies the contents of a render surface to a texture */\n    copyToTexture(\n        /** the render surface to copy from  */\n        sourceRenderSurfaceTexture: RenderTarget,\n        /** the texture to copy to */\n        destinationTexture: Texture,\n        /** the origin of the copy */\n        originSrc: { x: number; y: number },\n        /** the size of the copy */\n        size: { width: number; height: number },\n        /** the destination origin (top left to paste from!) */\n        originDest?: { x: number; y: number },\n    ): Texture\n\n    /** starts a render pass on the render target */\n    startRenderPass(\n        /** the render target to start the render pass on */\n        renderTarget: RenderTarget,\n        /* the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111* */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** clears the current render target to the specified color */\n    clear(\n        /** the render target to clear */\n        renderTarget: RenderTarget,\n        /** the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111 */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to   */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** finishes the current render pass */\n    finishRenderPass(renderTarget: RenderTarget): void\n\n    /**\n     * initializes a gpu render target. Both renderers use this function to initialize a gpu render target\n     * Its different type of object depending on the renderer.\n     */\n    initGpuRenderTarget(\n        /** the render target to initialize */\n        renderTarget: RenderTarget\n    ): RENDER_TARGET\n\n    /** called when a render target is resized */\n    resizeGpuRenderTarget(\n        /** the render target to resize */\n        renderTarget: RenderTarget\n    ): void\n\n    /** destroys the gpu render target */\n    destroyGpuRenderTarget(\n        /** the render target to destroy */\n        gpuRenderTarget: RENDER_TARGET\n    ): void\n}\n\n/**\n * A system that manages render targets. A render target is essentially a place where the shaders can color in the pixels.\n * The render target system is responsible for binding the render target to the renderer, and managing the viewport.\n * Render targets can be pushed and popped.\n *\n * To make it easier, you can also bind textures and canvases too. This will automatically create a render target for you.\n * The render target itself is a lot more powerful than just a texture or canvas,\n * as it can have multiple textures attached to it.\n * It will also give ou fine grain control over the stencil buffer / depth texture.\n * @example\n *\n * ```js\n *\n * // create a render target\n * const renderTarget = new RenderTarget({\n *   colorTextures: [new TextureSource({ width: 100, height: 100 })],\n * });\n *\n * // bind the render target\n * renderer.renderTarget.bind(renderTarget);\n *\n * // draw something!\n * ```\n * @memberof rendering\n */\nexport class RenderTargetSystem<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget> implements System\n{\n    /** When rendering of a scene begins, this is where the root render surface is stored */\n    public rootRenderTarget: RenderTarget;\n    /** This is the root viewport for the render pass*/\n    public rootViewPort = new Rectangle();\n    /** A boolean that lets the dev know if the current render pass is rendering to the screen. Used by some plugins */\n    public renderingToScreen: boolean;\n    /** the current active render target */\n    public renderTarget: RenderTarget;\n    /** the current active render surface that the render target is created from */\n    public renderSurface: RenderSurface;\n    /** the current viewport that the gpu is using */\n    public readonly viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    public readonly onRenderTargetChange = new SystemRunner('onRenderTargetChange');\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    public readonly projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    public readonly defaultClearColor: RgbaArray = [0, 0, 0, 0];\n    /** a reference to the adaptor that interfaces with WebGL / WebGP */\n    public readonly adaptor: RenderTargetAdaptor<RENDER_TARGET>;\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    private readonly _renderSurfaceToRenderTargetHash: Map<RenderSurface, RenderTarget>\n        = new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    private _gpuRenderTargetHash: Record<number, RENDER_TARGET> = Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    private readonly _renderTargetStack: RenderTargetAndFrame[] = [];\n    /** A reference to the renderer */\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /** called when dev wants to finish a render pass */\n    public finishRenderPass()\n    {\n        this.adaptor.finishRenderPass(this.renderTarget);\n    }\n\n    /**\n     * called when the renderer starts to render a scene.\n     * @param options\n     * @param options.target - the render target to render to\n     * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param options.clearColor - the color to clear to\n     * @param options.frame - the frame to render to\n     */\n    public renderStart({\n        target,\n        clear,\n        clearColor,\n        frame\n    }: {\n        target: RenderSurface;\n        clear: CLEAR_OR_BOOL;\n        clearColor: RgbaArray;\n        frame?: Rectangle\n    }): void\n    {\n        // TODO no need to reset this - use optimised index instead\n        this._renderTargetStack.length = 0;\n\n        this.push(\n            target,\n            clear,\n            clearColor,\n            frame\n        );\n\n        this.rootViewPort.copyFrom(this.viewport);\n        this.rootRenderTarget = this.renderTarget;\n        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n    }\n\n    /**\n     * Binding a render surface! This is the main function of the render target system.\n     * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n     * Once bound all draw calls will be rendered to the render surface.\n     *\n     * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n     * @param renderSurface - the render surface to bind\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to render to\n     * @returns the render target that was bound\n     */\n    public bind(\n        renderSurface: RenderSurface,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    ): RenderTarget\n    {\n        const renderTarget = this.getRenderTarget(renderSurface);\n\n        const didChange = this.renderTarget !== renderTarget;\n\n        this.renderTarget = renderTarget;\n        this.renderSurface = renderSurface;\n\n        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.pixelWidth !== gpuRenderTarget.width\n            || renderTarget.pixelHeight !== gpuRenderTarget.height)\n        {\n            this.adaptor.resizeGpuRenderTarget(renderTarget);\n\n            gpuRenderTarget.width = renderTarget.pixelWidth;\n            gpuRenderTarget.height = renderTarget.pixelHeight;\n        }\n\n        const source = renderTarget.colorTexture;\n        const viewport = this.viewport;\n\n        const pixelWidth = source.pixelWidth;\n        const pixelHeight = source.pixelHeight;\n\n        if (!frame && renderSurface instanceof Texture)\n        {\n            frame = renderSurface.frame;\n        }\n\n        if (frame)\n        {\n            const resolution = source._resolution;\n\n            viewport.x = ((frame.x * resolution) + 0.5) | 0;\n            viewport.y = ((frame.y * resolution) + 0.5) | 0;\n            viewport.width = ((frame.width * resolution) + 0.5) | 0;\n            viewport.height = ((frame.height * resolution) + 0.5) | 0;\n        }\n        else\n        {\n            viewport.x = 0;\n            viewport.y = 0;\n            viewport.width = pixelWidth;\n            viewport.height = pixelHeight;\n        }\n\n        calculateProjection(\n            this.projectionMatrix,\n            0, 0,\n            viewport.width / source.resolution,\n            viewport.height / source.resolution,\n            !renderTarget.isRoot\n        );\n\n        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n\n        if (didChange)\n        {\n            this.onRenderTargetChange.emit(renderTarget);\n        }\n\n        return renderTarget;\n    }\n\n    public clear(\n        target?: RenderSurface,\n        clear: CLEAR_OR_BOOL = CLEAR.ALL,\n        clearColor?: RgbaArray,\n    )\n    {\n        if (!clear) return;\n\n        if (target)\n        {\n            target = this.getRenderTarget(target);\n        }\n\n        this.adaptor.clear(\n            (target as RenderTarget) || this.renderTarget,\n            clear,\n            clearColor,\n            this.viewport\n        );\n    }\n\n    protected contextChange(): void\n    {\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    /**\n     * Push a render surface to the renderer. This will bind the render surface to the renderer,\n     * @param renderSurface - the render surface to push\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to use when rendering to the render surface\n     */\n    public push(\n        renderSurface: RenderSurface,\n        clear: CLEAR | boolean = CLEAR.ALL,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    )\n    {\n        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n\n        this._renderTargetStack.push({\n            renderTarget,\n            frame,\n        });\n\n        return renderTarget;\n    }\n\n    /** Pops the current render target from the renderer and restores the previous render target. */\n    public pop()\n    {\n        this._renderTargetStack.pop();\n\n        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n\n        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n    }\n\n    /**\n     * Gets the render target from the provide render surface. Eg if its a texture,\n     * it will return the render target for the texture.\n     * If its a render target, it will return the same render target.\n     * @param renderSurface - the render surface to get the render target for\n     * @returns the render target for the render surface\n     */\n    public getRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        if (((renderSurface as Texture).isTexture))\n        {\n            renderSurface = (renderSurface as Texture).source;\n        }\n\n        return this._renderSurfaceToRenderTargetHash.get(renderSurface)\n        ?? this._initRenderTarget(renderSurface);\n    }\n\n    /**\n     * Copies a render surface to another texture\n     * @param sourceRenderSurfaceTexture - the render surface to copy from\n     * @param destinationTexture - the texture to copy to\n     * @param originSrc - the origin of the copy\n     * @param originSrc.x - the x origin of the copy\n     * @param originSrc.y - the y origin of the copy\n     * @param size - the size of the copy\n     * @param size.width - the width of the copy\n     * @param size.height - the height of the copy\n     * @param originDest - the destination origin (top left to paste from!)\n     * @param originDest.x - the x origin of the paste\n     * @param originDest.y - the y origin of the paste\n     */\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest: { x: number; y: number; },\n    )\n    {\n        // fit the size to the source we don't want to go out of bounds\n\n        if (originSrc.x < 0)\n        {\n            size.width += originSrc.x;\n            originDest.x -= originSrc.x;\n            originSrc.x = 0;\n        }\n\n        if (originSrc.y < 0)\n        {\n            size.height += originSrc.y;\n            originDest.y -= originSrc.y;\n            originSrc.y = 0;\n        }\n\n        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n\n        size.width = Math.min(size.width, pixelWidth - originSrc.x);\n        size.height = Math.min(size.height, pixelHeight - originSrc.y);\n\n        return this.adaptor.copyToTexture(\n            sourceRenderSurfaceTexture,\n            destinationTexture,\n            originSrc,\n            size,\n            originDest\n        );\n    }\n\n    /**\n     * ensures that we have a depth stencil buffer available to render to\n     * This is used by the mask system to make sure we have a stencil buffer.\n     */\n    public ensureDepthStencil()\n    {\n        if (!this.renderTarget.stencil)\n        {\n            this.renderTarget.stencil = true;\n\n            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n        }\n    }\n\n    /** nukes the render target system */\n    public destroy()\n    {\n        (this._renderer as null) = null;\n\n        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) =>\n        {\n            if (renderTarget !== key)\n            {\n                renderTarget.destroy();\n            }\n        });\n\n        this._renderSurfaceToRenderTargetHash.clear();\n\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    private _initRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        let renderTarget: RenderTarget = null;\n\n        if (CanvasSource.test(renderSurface))\n        {\n            renderSurface = getCanvasTexture(renderSurface as ICanvas);\n        }\n\n        if (renderSurface instanceof RenderTarget)\n        {\n            renderTarget = renderSurface;\n        }\n        else if (renderSurface instanceof TextureSource)\n        {\n            renderTarget = new RenderTarget({\n                colorTextures: [renderSurface],\n            });\n\n            if (CanvasSource.test(renderSurface.source.resource))\n            {\n                renderTarget.isRoot = true;\n            }\n\n            // TODO add a test for this\n            renderSurface.once('destroy', () =>\n            {\n                renderTarget.destroy();\n\n                const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n\n                if (gpuRenderTarget)\n                {\n                    this._gpuRenderTargetHash[renderTarget.uid] = null;\n                    this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n                }\n            });\n        }\n\n        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n\n        return renderTarget;\n    }\n\n    public getGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        return this._gpuRenderTargetHash[renderTarget.uid]\n        || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n    }\n}\n","// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @memberof rendering\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @memberof rendering\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    public uid = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    private readonly _managedColorTextures: boolean = false;\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            this._managedColorTextures = true;\n\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     * @ignore\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this._managedColorTextures)\n        {\n            this.colorTextures.forEach((texture) =>\n            {\n                texture.destroy();\n            });\n        }\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n","import type { UNIFORM_TYPES_SINGLE } from '../types';\n\nfunction loopMatrix(col: number, row: number)\n{\n    const total = col * row;\n\n    return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\n\nexport const uboSyncFunctionsSTD40: Record<UNIFORM_TYPES_SINGLE, string> = {\n    f32: `\n        data[offset] = v;`,\n    i32: `\n        data[offset] = v;`,\n    'vec2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n    'vec3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n    'vec4<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n    'mat3x3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n    'mat4x4<f32>': `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n    'mat3x2<f32>': loopMatrix(3, 2),\n    'mat4x2<f32>': loopMatrix(4, 2),\n    'mat2x3<f32>': loopMatrix(2, 3),\n    'mat4x3<f32>': loopMatrix(4, 3),\n    'mat2x4<f32>': loopMatrix(2, 4),\n    'mat3x4<f32>': loopMatrix(3, 4),\n};\n\nexport const uboSyncFunctionsWGSL: Record<UNIFORM_TYPES_SINGLE, string> = {\n    ...uboSyncFunctionsSTD40,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `,\n};\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Container } from '../../../../scene/container/Container';\nimport { Texture } from '../texture/Texture';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { GetPixelsOutput } from '../texture/GenerateCanvas';\nimport type { GenerateTextureOptions } from './GenerateTextureSystem';\n\nconst imageTypes = {\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    webp: 'image/webp',\n};\n\ntype Formats = keyof typeof imageTypes;\n\n/**\n * Options for creating an image from a renderer.\n * @memberof rendering\n */\nexport interface ImageOptions\n{\n    /** The format of the image. */\n    format?: Formats;\n    /** The quality of the image. */\n    quality?: number;\n}\n\n/**\n * Options for extracting content from a renderer.\n * @memberof rendering\n */\nexport interface BaseExtractOptions\n{\n    /** The target to extract. */\n    target: Container | Texture;\n    /** The region of the target to extract. */\n    frame?: Rectangle;\n    /** The resolution of the extracted content. */\n    resolution?: number;\n    /** The color used to clear the extracted content. */\n    clearColor?: ColorSource;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n}\n/**\n * Options for extracting an HTMLImage from the renderer.\n * @memberof rendering\n */\nexport type ExtractImageOptions = BaseExtractOptions & ImageOptions;\n/**\n * Options for extracting and downloading content from a renderer.\n * @memberof rendering\n */\nexport type ExtractDownloadOptions = BaseExtractOptions & {\n    /** The filename to use when downloading the content. */\n    filename: string;\n};\n/**\n * Options for extracting content from a renderer.\n * @memberof rendering\n */\nexport type ExtractOptions = BaseExtractOptions | ExtractImageOptions | ExtractDownloadOptions;\n\n/**\n * This class provides renderer-specific plugins for exporting content from a renderer.\n * For instance, these plugins can be used for saving an Image, Canvas element or for exporting the raw image data (pixels).\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.extract` property.\n * @example\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application (extract will be auto-added to renderer)\n * const app = new Application();\n * await app.init();\n *\n * // Draw a red circle\n * const graphics = new Graphics()\n *     .circle(0, 0, 50);\n *     .fill(0xFF0000)\n *\n * // Render the graphics as an HTMLImageElement\n * const image = await app.renderer.extract.image(graphics);\n * document.body.appendChild(image);\n * @memberof rendering\n */\nexport class ExtractSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'extract',\n    } as const;\n\n    /** Default options for creating an image. */\n    public static defaultImageOptions: ImageOptions = {\n        /** The format of the image. */\n        format: 'png' as Formats,\n        /** The quality of the image. */\n        quality: 1,\n    };\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    private _normalizeOptions<T extends ExtractOptions>(\n        options: ExtractImageOptions | Container | Texture,\n        defaults: Partial<T> = {},\n    ): T\n    {\n        if (options instanceof Container || options instanceof Texture)\n        {\n            return {\n                target: options,\n                ...defaults\n            } as T;\n        }\n\n        return {\n            ...defaults,\n            ...options,\n        } as T;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     * @param options - The options for creating the image, or the target to extract\n     * @returns - HTML Image of the target\n     */\n    public async image(options: ExtractImageOptions | Container | Texture): Promise<HTMLImageElement>\n    {\n        const image = new Image();\n\n        image.src = await this.base64(options);\n\n        return image;\n    }\n\n    /**\n     * Will return a base64 encoded string of this target. It works by calling\n     * `Extract.canvas` and then running toDataURL on that.\n     * @param options - The options for creating the image, or the target to extract\n     */\n    public async base64(options: ExtractImageOptions | Container | Texture): Promise<string>\n    {\n        options = this._normalizeOptions<ExtractImageOptions>(\n            options,\n            ExtractSystem.defaultImageOptions\n        );\n\n        const { format, quality } = options;\n\n        const canvas = this.canvas(options);\n\n        if (canvas.toBlob !== undefined)\n        {\n            return new Promise<string>((resolve, reject) =>\n            {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                canvas.toBlob!((blob) =>\n                {\n                    if (!blob)\n                    {\n                        reject(new Error('ICanvas.toBlob failed!'));\n\n                        return;\n                    }\n\n                    const reader = new FileReader();\n\n                    reader.onload = () => resolve(reader.result as string);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }, imageTypes[format], quality);\n            });\n        }\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(imageTypes[format], quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n\n            return new Promise<string>((resolve, reject) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, '\n            + 'or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     * @param options - The options for creating the canvas, or the target to extract\n     * @returns - A Canvas element with the texture rendered on.\n     */\n    public canvas(options: ExtractOptions | Container | Texture): ICanvas\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n\n        if (target instanceof Texture)\n        {\n            return renderer.texture.generateCanvas(target);\n        }\n\n        const texture = renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const canvas = renderer.texture.generateCanvas(texture);\n\n        texture.destroy();\n\n        return canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     * @param options - The options for extracting the image, or the target to extract\n     * @returns - One-dimensional array containing the pixel data of the entire texture\n     */\n    public pixels(options: ExtractOptions | Container | Texture): GetPixelsOutput\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n        const texture = target instanceof Texture\n            ? target\n            : renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const pixelInfo = renderer.texture.getPixels(texture);\n\n        if (target instanceof Container)\n        {\n            // destroy generated texture\n            texture.destroy();\n        }\n\n        return pixelInfo;\n    }\n\n    /**\n     * Will return a texture of the target\n     * @param options - The options for creating the texture, or the target to extract\n     * @returns - A texture of the target\n     */\n    public texture(options: ExtractOptions | Container | Texture): Texture\n    {\n        options = this._normalizeOptions(options);\n\n        if (options.target instanceof Texture) return options.target;\n\n        return this._renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n    }\n\n    /**\n     * Will extract a HTMLImage of the target and download it\n     * @param options - The options for downloading and extracting the image, or the target to extract\n     */\n    public download(options: ExtractDownloadOptions | Container | Texture)\n    {\n        options = this._normalizeOptions<ExtractDownloadOptions>(options);\n\n        const canvas = this.canvas(options);\n\n        const link = document.createElement('a');\n\n        link.download = options.filename ?? 'image.png';\n        link.href = canvas.toDataURL('image/png');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n\n    /**\n     * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n     * @param options - The options for logging the image, or the target to log\n     */\n    public log(options: (ExtractOptions & {width?: number}) | Container | Texture)\n    {\n        const width = options.width ?? 200;\n\n        options = this._normalizeOptions(options);\n\n        const canvas = this.canvas(options);\n\n        const base64 = canvas.toDataURL();\n\n        // eslint-disable-next-line no-console\n        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n\n        const style = [\n            'font-size: 1px;',\n            `padding: ${width}px ${300}px;`,\n            `background: url(${base64}) no-repeat;`,\n            'background-size: contain;',\n        ].join(' ');\n\n        // eslint-disable-next-line no-console\n        console.log('%c ', style);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { FilterEffect } from '../../../../filters/FilterEffect';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { BlendModeFilter } from '../../../../filters/blend-modes/BlendModeFilter';\nimport type { FilterInstruction } from '../../../../filters/FilterSystem';\nimport type { Renderer } from '../../types';\nimport type { Instruction } from '../instructions/Instruction';\nimport type { InstructionSet } from '../instructions/InstructionSet';\nimport type { InstructionPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { BLEND_MODES } from '../state/const';\n\ninterface AdvancedBlendInstruction extends Instruction\n{\n    renderPipeId: 'blendMode',\n    blendMode: BLEND_MODES,\n    activeBlend: Renderable[],\n}\n\n// class map\nconst BLEND_MODE_FILTERS: Partial<Record<BLEND_MODES, new () => BlendModeFilter>> = {} as const;\n\nextensions.handle(ExtensionType.BlendMode, (value) =>\n{\n    if (!value.name)\n    {\n        throw new Error('BlendMode extension must have a name property');\n    }\n    BLEND_MODE_FILTERS[value.name as BLEND_MODES] = value.ref;\n}, (value) =>\n{\n    delete BLEND_MODE_FILTERS[value.name as BLEND_MODES];\n});\n\n/**\n * This Pipe handles the blend mode switching of the renderer.\n * It will insert instructions into the {@link renderers.InstructionSet} to switch the blend mode according to the\n * blend modes of the scene graph.\n *\n * This pipe is were wwe handle Advanced blend modes. Advanced blend modes essentially wrap the renderables\n * in a filter that applies the blend mode.\n *\n * You only need to use this class if you are building your own render instruction set rather than letting PixiJS build\n * the instruction set for you by traversing the scene graph\n * @memberof rendering\n */\nexport class BlendModePipe implements InstructionPipe<AdvancedBlendInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'blendMode',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _renderableList: Renderable[];\n    private _activeBlendMode: BLEND_MODES;\n\n    private _isAdvanced = false;\n\n    private _filterHash: Partial<Record<BLEND_MODES, FilterEffect>> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n     * @param renderable - The renderable we are adding to the instruction set\n     * @param blendMode - The blend mode of the renderable\n     * @param instructionSet - The instruction set we are adding to\n     */\n    public setBlendMode(renderable: Renderable, blendMode: BLEND_MODES, instructionSet: InstructionSet)\n    {\n        if (this._activeBlendMode === blendMode)\n        {\n            if (this._isAdvanced) this._renderableList.push(renderable);\n\n            return;\n        }\n\n        this._activeBlendMode = blendMode;\n\n        if (this._isAdvanced)\n        {\n            this._endAdvancedBlendMode(instructionSet);\n        }\n\n        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n\n        if (this._isAdvanced)\n        {\n            this._beginAdvancedBlendMode(instructionSet);\n\n            this._renderableList.push(renderable);\n        }\n    }\n\n    private _beginAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const blendMode = this._activeBlendMode;\n\n        if (!BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS])\n        {\n            // #if _DEBUG\n            warn(`Unable to assign BlendMode: '${blendMode}'. `\n            + `You may want to include: import 'pixi.js/advanced-blend-modes'`);\n            // #endif\n\n            return;\n        }\n\n        // this does need an execute?\n        if (!this._filterHash[blendMode])\n        {\n            this._filterHash[blendMode] = new FilterEffect({\n                filters: [new BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS]()]\n            });\n        }\n\n        const instruction: FilterInstruction = {\n            renderPipeId: 'filter',\n            action: 'pushFilter',\n            renderables: [],\n            filterEffect: this._filterHash[blendMode],\n            canBundle: false,\n        };\n\n        this._renderableList = instruction.renderables;\n        instructionSet.add(instruction);\n    }\n\n    private _endAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._renderableList = null;\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    /**\n     * called when the instruction build process is starting this will reset internally to the default blend mode\n     * @internal\n     * @ignore\n     */\n    public buildStart()\n    {\n        this._isAdvanced = false;\n    }\n\n    /**\n     * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n     * active, we add the final render instructions added to the instruction set\n     * @param instructionSet - The instruction set we are adding to\n     * @internal\n     * @ignore\n     */\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        if (this._isAdvanced)\n        {\n            this._endAdvancedBlendMode(instructionSet);\n        }\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public destroy()\n    {\n        this._renderer = null;\n        this._renderableList = null;\n\n        for (const i in this._filterHash)\n        {\n            this._filterHash[i as BLEND_MODES].destroy();\n        }\n\n        this._filterHash = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Point } from '../../../../maths/point/Point';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { type Renderer, RendererType } from '../../types';\nimport { UniformGroup } from '../shader/UniformGroup';\n\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { GlRenderTargetSystem } from '../../gl/renderTarget/GlRenderTargetSystem';\nimport type { GpuRenderTargetSystem } from '../../gpu/renderTarget/GpuRenderTargetSystem';\nimport type { WebGPURenderer } from '../../gpu/WebGPURenderer';\nimport type { UboSystem } from '../shader/UboSystem';\nimport type { System } from '../system/System';\n\nexport type GlobalUniformGroup = UniformGroup<{\n    uProjectionMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldTransformMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldColorAlpha: { value: Float32Array; type: 'vec4<f32>' }\n    uResolution: { value: number[]; type: 'vec2<f32>' }\n}>;\n\nexport interface GlobalUniformOptions\n{\n    size?: number[],\n    projectionMatrix?: Matrix,\n    worldTransformMatrix?: Matrix\n    worldColor?: number\n    offset?: PointData\n}\n\nexport interface GlobalUniformData\n{\n    projectionMatrix: Matrix\n    worldTransformMatrix: Matrix\n    worldColor: number\n    resolution: number[]\n    offset: PointData\n    bindGroup: BindGroup\n}\n\ninterface GlobalUniformRenderer\n{\n    renderTarget: GlRenderTargetSystem | GpuRenderTargetSystem\n    renderPipes: Renderer['renderPipes'];\n    ubo: UboSystem;\n    type: RendererType;\n}\n\n/**\n * System plugin to the renderer to manage global uniforms for the renderer.\n * @memberof rendering\n */\nexport class GlobalUniformSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'globalUniforms',\n    } as const;\n\n    private readonly _renderer: GlobalUniformRenderer;\n\n    private _stackIndex = 0;\n    private _globalUniformDataStack: GlobalUniformData[] = [];\n\n    private readonly _uniformsPool: GlobalUniformGroup[] = [];\n    private readonly _activeUniforms: GlobalUniformGroup[] = [];\n\n    private readonly _bindGroupPool: BindGroup[] = [];\n    private readonly _activeBindGroups: BindGroup[] = [];\n\n    private _currentGlobalUniformData: GlobalUniformData;\n\n    constructor(renderer: GlobalUniformRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public reset()\n    {\n        this._stackIndex = 0;\n\n        for (let i = 0; i < this._activeUniforms.length; i++)\n        {\n            this._uniformsPool.push(this._activeUniforms[i]);\n        }\n\n        for (let i = 0; i < this._activeBindGroups.length; i++)\n        {\n            this._bindGroupPool.push(this._activeBindGroups[i]);\n        }\n\n        this._activeUniforms.length = 0;\n        this._activeBindGroups.length = 0;\n    }\n\n    public start(options: GlobalUniformOptions): void\n    {\n        this.reset();\n\n        this.push(options);\n    }\n\n    public bind({\n        size,\n        projectionMatrix,\n        worldTransformMatrix,\n        worldColor,\n        offset,\n    }: GlobalUniformOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.renderTarget;\n\n        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n            projectionData: renderTarget,\n            worldTransformMatrix: new Matrix(),\n            worldColor: 0xFFFFFFFF,\n            offset: new Point(),\n        };\n\n        const globalUniformData: GlobalUniformData = {\n            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n            resolution: size || renderTarget.size,\n            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n            worldColor: worldColor || currentGlobalUniformData.worldColor,\n            offset: offset || currentGlobalUniformData.offset,\n            bindGroup: null,\n        };\n\n        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n\n        this._activeUniforms.push(uniformGroup);\n\n        const uniforms = uniformGroup.uniforms;\n\n        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n\n        uniforms.uResolution = globalUniformData.resolution;\n\n        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n\n        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n\n        color32BitToUniform(\n            globalUniformData.worldColor,\n            uniforms.uWorldColorAlpha,\n            0\n        );\n\n        uniformGroup.update();\n\n        let bindGroup: BindGroup;\n\n        if ((this._renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            bindGroup = (this._renderer as WebGPURenderer).renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n        }\n        else\n        {\n            bindGroup = this._bindGroupPool.pop() || new BindGroup();\n            this._activeBindGroups.push(bindGroup);\n            bindGroup.setResource(uniformGroup, 0);\n        }\n\n        globalUniformData.bindGroup = bindGroup;\n\n        this._currentGlobalUniformData = globalUniformData;\n    }\n\n    public push(options: GlobalUniformOptions)\n    {\n        this.bind(options);\n\n        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n    }\n\n    public pop()\n    {\n        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n\n        // for webGL we need to update the uniform group here\n        // as we are not using bind groups\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            (this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup).update();\n        }\n    }\n\n    get bindGroup(): BindGroup\n    {\n        return this._currentGlobalUniformData.bindGroup;\n    }\n\n    get uniformGroup()\n    {\n        return this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup;\n    }\n\n    private _createUniforms(): GlobalUniformGroup\n    {\n        const globalUniforms = new UniformGroup({\n            uProjectionMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uWorldTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n            uWorldColorAlpha: { value: new Float32Array(4), type: 'vec4<f32>' },\n            uResolution: { value: [0, 0], type: 'vec2<f32>' },\n        }, {\n            isStatic: true,\n        });\n\n        return globalUniforms;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { Buffer } from '../buffer/Buffer';\nimport { BufferUsage } from '../buffer/const';\n\nimport type { System } from '../system/System';\nimport type { UboElement, UboLayout, UniformData, UniformsSyncCallback } from './types';\nimport type { UniformGroup } from './UniformGroup';\n\nexport interface UboAdaptor\n{\n    createUboElements: (uniformData: UniformData[]) => UboLayout;\n    generateUboSync: (uboElements: UboElement[]) => UniformsSyncCallback;\n}\n\n/**\n * System plugin to the renderer to manage uniform buffers.\n * @memberof rendering\n */\nexport class UboSystem implements System\n{\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    private _syncFunctionHash: Record<string, {\n        layout: UboLayout,\n        syncFunction: (uniforms: Record<string, any>, data: Float32Array, offset: number) => void\n    }> = Object.create(null);\n\n    private readonly _adaptor: UboAdaptor;\n\n    constructor(adaptor: UboAdaptor)\n    {\n        this._adaptor = adaptor;\n\n        // Validation check that this environment support `new Function`\n        this._systemCheck();\n    }\n\n    /**\n     * Overrideable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     */\n    private _systemCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n                 + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n\n    public ensureUniformGroup(uniformGroup: UniformGroup): void\n    {\n        const uniformData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n    }\n\n    public getUniformGroupData(uniformGroup: UniformGroup)\n    {\n        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n    }\n\n    private _initUniformGroup(uniformGroup: UniformGroup)\n    {\n        const uniformGroupSignature = uniformGroup._signature;\n\n        let uniformData = this._syncFunctionHash[uniformGroupSignature];\n\n        if (!uniformData)\n        {\n            const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n\n            const layout = this._adaptor.createUboElements(elements);\n\n            const syncFunction = this._generateUboSync(layout.uboElements);\n\n            uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n                layout,\n                syncFunction\n            };\n        }\n\n        return this._syncFunctionHash[uniformGroupSignature];\n    }\n\n    private _generateUboSync(\n        uboElements: UboElement[],\n    ): UniformsSyncCallback\n    {\n        return this._adaptor.generateUboSync(uboElements);\n    }\n\n    public syncUniformGroup(uniformGroup: UniformGroup, data?: Float32Array, offset?: number): boolean\n    {\n        const uniformGroupData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformGroupData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n\n        data ||= (uniformGroup.buffer.data as Float32Array);\n        offset ||= 0;\n\n        uniformGroupData.syncFunction(uniformGroup.uniforms, data, offset);\n\n        return true;\n    }\n\n    public updateUniformGroup(uniformGroup: UniformGroup): boolean\n    {\n        if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n        uniformGroup._dirtyId = 0;\n\n        const synced = this.syncUniformGroup(uniformGroup);\n\n        uniformGroup.buffer.update();\n\n        return synced;\n    }\n\n    public destroy(): void\n    {\n        this._syncFunctionHash = null;\n    }\n}\n","import { CanvasSource } from '../sources/CanvasSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\n\nconst canvasCache: Map<ICanvas, Texture> = new Map();\n\nexport function getCanvasTexture(canvas: ICanvas, options?: CanvasSourceOptions): Texture\n{\n    if (!canvasCache.has(canvas))\n    {\n        const texture = new Texture({\n            source: new CanvasSource({\n                resource: canvas,\n                ...options,\n            })\n        });\n\n        const onDestroy = () =>\n        {\n            if (canvasCache.get(canvas) === texture)\n            {\n                canvasCache.delete(canvas);\n            }\n        };\n\n        texture.once('destroy', onDestroy);\n        texture.source.once('destroy', onDestroy);\n\n        canvasCache.set(canvas, texture);\n    }\n\n    return canvasCache.get(canvas);\n}\n\nexport function hasCachedCanvasTexture(canvas: ICanvas): boolean\n{\n    return canvasCache.has(canvas);\n}\n"],"sourceRoot":""}