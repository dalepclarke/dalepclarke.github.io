{"version":3,"sources":["webpack:///../../../../../src/rendering/renderers/shared/state/State.ts","webpack:///../../../../src/rendering/high-shader/shader-bits/globalUniformsBit.ts","webpack:///../../../../../src/rendering/renderers/shared/shader/const.ts","webpack:///../../../../src/rendering/high-shader/shader-bits/colorBit.ts","webpack:///../../../../src/scene/graphics/gpu/colorToUniform.ts","webpack:///../../../../../src/rendering/renderers/shared/texture/TexturePool.ts","webpack:///../../../../../../src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts","webpack:///../../../../../../../src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts","webpack:///../../../../../../src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts","webpack:///../../../../../src/rendering/renderers/shared/shader/UniformGroup.ts","webpack:///../../../../src/rendering/high-shader/shader-bits/localUniformBit.ts","webpack:///../../../src/scene/sprite/BatchableSprite.ts","webpack:///../../../../src/rendering/high-shader/shader-bits/roundPixelsBit.ts","webpack:///../../../../../../../src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts","webpack:///../../../../../src/rendering/high-shader/compiler/utils/compileHooks.ts","webpack:///../../../../../../../src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts","webpack:///../../../../../src/rendering/high-shader/compiler/utils/compileOutputs.ts","webpack:///../../../../../src/rendering/high-shader/compiler/utils/compileInputs.ts","webpack:///../../../../src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts","webpack:///../../../../../src/rendering/renderers/shared/utils/createIdFromString.ts","webpack:///../../../../../src/rendering/high-shader/compiler/utils/addBits.ts","webpack:///../../../../../../src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts","webpack:///../../../src/rendering/high-shader/compileHighShaderToProgram.ts","webpack:///../../../src/rendering/high-shader/defaultProgramTemplate.ts","webpack:///../../../../../../src/rendering/renderers/gl/shader/program/getTestContext.ts","webpack:///../../../../../../src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts","webpack:///../../../../../../src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts","webpack:///../../../../../src/rendering/renderers/gl/shader/GlProgram.ts","webpack:///../../../../../../../src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts","webpack:///../../../../../../src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts","webpack:///../../../../../src/rendering/renderers/shared/shader/Shader.ts","webpack:///../../../../../src/rendering/renderers/gpu/shader/GpuProgram.ts","webpack:///../../../../../../../src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts","webpack:///../../../../src/rendering/high-shader/compiler/compileHighShader.ts","webpack:///../../../../../../src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts","webpack:///../../../../../../src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts","webpack:///../../../src/rendering/renderers/types.ts","webpack:///../../../../../src/rendering/high-shader/compiler/utils/injectBits.ts"],"names":["blendModeIds","normal","add","multiply","screen","overlay","erase","BLEND","OFFSET","CULLING","DEPTH_TEST","WINDING","DEPTH_MASK","_State","constructor","this","data","blendMode","polygonOffset","blend","depthMask","value","culling","clockwiseFrontFace","_blendMode","_blendModeId","_polygonOffset","offsets","toString","state","depthTest","default2d","for2d","State","globalUniformsBit","name","vertex","header","globalUniformsBitGl","ShaderStage","ShaderStage2","colorBit","main","colorBitGl","color32BitToUniform","abgr","out","offset","alpha","count","TexturePoolClass","textureOptions","_poolKeyHash","Object","create","_texturePool","enableFullScreen","createTexture","pixelWidth","pixelHeight","antialias","textureSource","TextureSource","width","height","resolution","autoGarbageCollect","Texture","source","label","getOptimalTexture","frameWidth","frameHeight","arguments","length","undefined","po2Width","Math","ceil","po2Height","nextPow2","key","texture","pop","_resolution","frame","x","y","updateUvs","uid","getSameSizeTexture","returnTexture","renderTexture","push","clear","destroyTextures","i","textures","j","destroy","TexturePool","generateGpuLayoutGroups","_ref","groups","layout","group","isUniform","binding","visibility","VERTEX","FRAGMENT","buffer","type","sampler","sampleType","viewDimension","multisampled","addProgramDefines","src","isES300","isFragment","replace","removeStructAndGroupDuplicates","vertexStructsAndGroups","fragmentStructsAndGroups","structNameSet","Set","dupeGroupKeySet","structs","filter","struct","has","_UniformGroup","uniformStructures","options","_touched","_resourceType","_resourceId","isUniformGroup","_dirtyId","destroyed","defaultOptions","uniforms","_uniformData$size","_uniformData$value","uniformData","size","getDefaultUniformValue","ubo","isStatic","_signature","createIdFromString","keys","map","join","update","UniformGroup","localUniformBit","end","localUniformBitGroup2","localUniformBitGl","BatchableSprite","vertexSize","indexSize","location","batcher","batch","roundPixels","renderable","groupBlendMode","packAttributes","float32View","uint32View","index","textureId","sprite","wt","groupTransform","a","b","c","d","tx","ty","bounds","w0","maxX","w1","minX","h0","maxY","h1","minY","uvs","argb","groupColorAlpha","textureIdAndRound","x0","y0","x1","y1","x2","y2","x3","y3","packIndex","indexBuffer","indicesOffset","reset","roundPixelsBit","roundPixelsBitGl","ensurePrecision","maxSupportedPrecision","maxSupportedFragmentPrecision","maxSupportedVertexPrecision","substring","precision","requestedFragmentPrecision","requestedVertexPrecision","findHooksRx","compileHooks","programSrc","_programSrc$match$map","_programSrc$match","parts","partMatches","match","hook","forEach","insertVersion","extractOutputs","fragmentSource","regex","exec","extractVariableName","stripVariable","compileOutputs","fragments","template","results","fragment","mainStruct","sort","inValue","indexOf","mainStart","mainEnd","compiledCode","extractInputs","compileInputs","mainInput","finalString","cleanedString","textureBatchBitGpuCache","generateBindingSrc","maxTextures","bindingIndex","generateSampleSrc","generateTextureBatchBit","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl","idCounts","idHash","groupId","id","addBits","srcParts","toLocaleLowerCase","part","sanitisedPart","warn","Float32Array","compileHighShaderGpuProgram","bits","compileHighShader","fragmentGPUTemplate","vertexGPUTemplate","GpuProgram","from","entryPoint","compileHighShaderGlProgram","_ref2","GlProgram","compileHighShaderGl","vertexGlTemplate","fragmentGlTemplate","context","getTestContext","_context","isContextLost","canvas","DOMAdapter","get","createCanvas","getContext","WGSL_TO_VERTEX_TYPES","f32","vec2f","vec3f","vec4f","i32","u32","bool","extractAttributesFromGpuProgram","mainVertStart","arrowFunctionStart","functionArgsSubstring","inputsRegex","_WGSL_TO_VERTEX_TYPES","format","parseInt","stride","getAttributeInfoFromFormat","instance","start","generateLayoutHash","processes","stripVersion","setProgramName","programCache","_GlProgram","preprocessorOptions","preferredFragmentPrecision","preferredVertexPrecision","getMaxFragmentPrecision","processKey","processOptions","_key","_attributeData","_uniformData","_uniformBlockData","transformFeedbackVaryings","fragmentNameCache","VertexNameCache","nameCache","shaderName","extractStructAndGroups","wgsl","_wgsl$match","_wgsl$match$map$filte","_wgsl$match2","linePattern","groupPattern","bindingPattern","namePattern","typePattern","structPattern","structMemberPattern","structName","item","members","reduce","acc","member","name2","split","trim","some","Shader","EventEmitter","_uniformBindMap","_ownedBindGroups","gpuProgram","glProgram","resources","compatibleRenderers","groupMap","RendererType","WEBGPU","WEBGL","nameHash","Error","uniformName","groupData","structsAndGroups","99","BindGroup","bindTick","setResource","_buildResourceAccessor","addResource","groupIndex","bindIndex","_a","_b","uniformsOut","defineProperty","getResource","set","destroyPrograms","_this$gpuProgram","_this$glProgram","emit","removeAllListeners","bindGroup","gpu","gl","rest","_this$layout$","_this$layout$2","_layoutKey","gpuLayout","autoAssignGlobalUniforms","globalUniforms","autoAssignLocalUniforms","localUniforms","_generateProgramKey","bigKey","_this$_attributeData","cacheMap","bitCacheMap","Map","CACHE_UID","cacheId","generateCacheId","compileInputsAndOutputs","compileBits","vertexFragments","shaderBit","v","fragmentFragments","compiledVertex","compiledFragment","highFragment","vertexParts","fragmentParts","injectBits","maxFragmentPrecision","getShaderPrecisionFormat","shaderFragment","FRAGMENT_SHADER","HIGH_FLOAT","attributeFormatData","uint8x2","normalised","uint8x4","sint8x2","sint8x4","unorm8x2","unorm8x4","snorm8x2","snorm8x4","uint16x2","uint16x4","sint16x2","sint16x4","unorm16x2","unorm16x4","snorm16x2","snorm16x4","float16x2","float16x4","float32","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","sint32x2","sint32x3","sint32x4","_attributeFormatData$","RendererType2","templateSrc","toInject"],"mappings":"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","file":"js/chunk-5e8062ac.1a22d143.js","sourcesContent":["/* eslint-disable max-len */\nimport type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n","export enum ShaderStage\n    {\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n","export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @memberof rendering\n * @name TexturePool\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: true,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param renderTexture - The renderTexture to free\n     */\n    public returnTexture(renderTexture: Texture): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\nexport const TexturePool = new TexturePoolClass();\n","import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n","export function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n","import type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n","import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\nimport type { UniformData } from './types';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @memberof rendering\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types {@link UNIFORM_TYPES}\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```glsl\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n *\n *\n *  ```\n * @memberof rendering\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /** used internally to know if a uniform group was used in the last render pass */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid = uid('uniform');\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    public _resourceType = 'uniformGroup';\n    /** the resource id used internally by the renderer to build bind group keys */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     * @ignore\n     */\n    public readonly _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n","export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","import type { Batch, BatchableObject, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements BatchableObject\n{\n    public indexStart: number;\n    public renderable: Container;\n\n    // batch specific..\n    public vertexSize = 4;\n    public indexSize = 6;\n    public texture: Texture;\n\n    public textureId: number;\n    public location = 0; // location in the buffer\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public bounds: BoundsData;\n    public roundPixels: 0 | 1 = 0;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    )\n    {\n        const sprite = this.renderable;\n        const texture = this.texture;\n\n        const wt = sprite.groupTransform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = this.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = sprite.groupColorAlpha;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n        this.bounds = null;\n    }\n}\n","export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n","import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n","export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n","export function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n","function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n                ${results\n        .sort()\n        .map((inValue) => ` ${extractVariableName(inValue)}`)\n        .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n","function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n","import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(16)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n                main: `\n    \n                ${generateSampleGlSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n","const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n","import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n","/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n","import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n","const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n","import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\n\nlet context: GlRenderingContext;\n\n/**\n * returns a little WebGL context to use for program inspection.\n * @static\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext\n{\n    if (!context || context?.isContextLost())\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        context = canvas.getContext('webgl', {}) as GlRenderingContext;\n    }\n\n    return context;\n}\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n","import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\nexport interface GlAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @memberof rendering\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @memberof rendering\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     * @ignore\n     */\n    public readonly _key: number;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n","const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n","export interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n","/* eslint-disable no-new */\nimport EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @memberof rendering\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\ninterface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\ninterface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\ninterface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @memberof rendering\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @memberof rendering\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\nexport interface IShaderWithGroups extends ShaderWithGroupsDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @memberof rendering\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @memberof rendering\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event rendering.Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param {ShaderWithResourcesDescriptor} options - The options for the shader using ShaderWithResourcesDescriptor.\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            if (!gpuProgram)\n            {\n                // build out a dummy bind group..\n                groupMap = {};\n                groups = {\n                    99: new BindGroup(),\n                };\n\n                this._ownedBindGroups.push(groups[99]);\n\n                let bindTick = 0;\n\n                for (const i in resources)\n                {\n                    // Yes i know this is a little strange, but wil line up the shaders neatly\n                    // basically we want to be driven by how webGPU does things.\n                    // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                    nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                    groupMap[99] = groupMap[99] || {};\n                    groupMap[99][bindTick] = i;\n\n                    bindTick++;\n                }\n            }\n            else\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupMap = {};\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            groups = {};\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is layed out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @memberof rendering\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @memberof rendering\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @memberof rendering\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @memberof rendering\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @memberof rendering\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n\n","export function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n","import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n","import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n","import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n","import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/** A generic renderer. */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/* eslint-disable @typescript-eslint/indent */\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter weather or not you want to do somthing in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n *\n */\nexport enum RendererType\n{\n    WEBGL = 0b01,\n    WEBGPU = 0b10,\n    BOTH = 0b11\n}\n\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n","/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n"],"sourceRoot":""}