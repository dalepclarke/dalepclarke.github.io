{"version":3,"sources":["webpack:///../../src/app/TickerPlugin.ts","webpack:///../../../src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","webpack:///../../../../src/scene/text-html/utils/loadFontAsBase64.ts","webpack:///../../../src/scene/sprite-nine-slice/NineSliceGeometry.ts","webpack:///../../../../src/scene/sprite-tiling/utils/QuadGeometry.ts","webpack:///../../src/filters/FilterPipe.ts","webpack:///../../../../src/scene/text-bitmap/asset/bitmapFontTextParser.ts","webpack:///../../../../src/scene/sprite-tiling/shader/tilingBit.ts","webpack:///../../../src/scene/text-html/init.ts","webpack:///../../src/app/ResizePlugin.ts","webpack:///../../../../src/scene/mesh/shared/MeshPipe.ts","webpack:///../../../../../src/scene/text/canvas/utils/getCanvasFillStyle.ts","webpack:///../../src/filters/init.ts","webpack:///../../../src/scene/text-html/HTMLTextPipe.ts","webpack:///../../../../src/scene/text/sdfShader/SdfShader.ts","webpack:///../../../../src/scene/text-bitmap/asset/bitmapFontXMLStringParser.ts","webpack:///../../../src/utils/browser/isSafari.ts","webpack:///../../../../src/scene/text-bitmap/asset/bitmapFontXMLParser.ts","webpack:///../../../../../src/rendering/renderers/shared/texture/CanvasPool.ts","webpack:///../../../../src/scene/sprite-tiling/utils/applyMatrix.ts","webpack:///../../../../src/scene/mesh/shared/MeshGeometry.ts","webpack:///../../../src/scene/text-bitmap/init.ts","webpack:///../../../src/scene/text-html/HTMLTextSystem.ts","webpack:///../../../../src/scene/mesh/shared/BatchableMesh.ts","webpack:///../../../../../src/scene/text/sdfShader/shader-bits/mSDFBit.ts","webpack:///../../../src/scene/text-bitmap/BitmapFontManager.ts","webpack:///../../../src/scene/graphics/init.ts","webpack:///../../../../src/scene/container/bounds/getFastGlobalBounds.ts","webpack:///../../../../src/scene/text-html/utils/loadFontCSS.ts","webpack:///../../../src/scene/text/init.ts","webpack:///../../../src/scene/mesh-plane/PlaneGeometry.ts","webpack:///../../../../src/scene/sprite-tiling/utils/setUvs.ts","webpack:///../../../../src/scene/text-html/utils/loadSVGImage.ts","webpack:///../../../src/scene/sprite-tiling/init.ts","webpack:///../../../src/scene/sprite-tiling/TilingSpritePipe.ts","webpack:///../../../../src/scene/text-html/utils/textStyleToCSS.ts","webpack:///../../../../src/scene/text-html/utils/getFontCss.ts","webpack:///../../../../src/scene/text/utils/getPo2TextureFromSource.ts","webpack:///../../../../../src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","webpack:///../../../../src/scene/text-html/utils/getSVGUrl.ts","webpack:///../../../../src/scene/sprite-tiling/shader/TilingSpriteShader.ts","webpack:///../../../../src/scene/text/canvas/CanvasTextPipe.ts","webpack:///../../../src/scene/text-bitmap/AbstractBitmapFont.ts","webpack:///../../../src/scene/text-bitmap/BitmapFont.ts","webpack:///../../../../src/scene/text/canvas/CanvasTextSystem.ts","webpack:///../../../../src/scene/text-bitmap/utils/resolveCharacters.ts","webpack:///../../../src/scene/text-bitmap/BitmapTextPipe.ts","webpack:///../../../src/scene/mesh/init.ts","webpack:///../../../../src/scene/sprite-tiling/utils/setPositions.ts","webpack:///../../../src/scene/text-html/HtmlTextStyle.ts","webpack:///../../../../src/scene/graphics/shared/GraphicsPipe.ts","webpack:///../../../../src/scene/text-html/utils/measureHtmlText.ts","webpack:///../../../../src/scene/text-bitmap/asset/loadBitmapFont.ts","webpack:///../../../../src/scene/container/bounds/getRenderableBounds.ts","webpack:///../../../../src/scene/text-html/utils/extractFontFamilies.ts","webpack:///../../../src/scene/text-bitmap/DynamicBitmapFont.ts","webpack:///../../../src/scene/text-html/HTMLTextRenderData.ts","webpack:///../../src/filters/FilterSystem.ts","webpack:///../../../../src/scene/text-bitmap/utils/getBitmapTextLayout.ts","webpack:///../../../../../src/rendering/renderers/gl/shader/batchSamplersUniformGroup.ts","webpack:///../../../src/utils/canvas/getCanvasBoundingBox.ts","webpack:///../../../../src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","webpack:///../../src/app/init.ts","webpack:///../../../src/scene/sprite-nine-slice/init.ts"],"names":["TickerPlugin","options","Object","assign","autoStart","sharedTicker","defineProperty","this","set","ticker","_ticker","remove","render","add","UPDATE_PRIORITY","LOW","get","stop","start","Ticker","shared","oldTicker","destroy","extension","ExtensionType","Application","NineSliceSpritePipe","constructor","renderer","_gpuSpriteHash","create","_renderer","addRenderable","sprite","_instructionSet","gpuSprite","_getGpuSprite","_didSpriteUpdate","_updateBatchableSprite","renderPipes","batch","addToBatch","updateRenderable","uid","batcher","updateElement","validateRenderable","texture","_texture","_source","checkAndUpdateTexture","destroyRenderable","batchableSprite","BigPool","return","geometry","update","_initGPUSprite","batchableMesh","BatchableMesh","NineSliceGeometry","mesh","roundPixels","_roundPixels","on","i","type","WebGLPipes","WebGPUPipes","CanvasPipes","name","loadFontAsBase64","url","response","DOMAdapter","fetch","blob","reader","FileReader","dataSrc","Promise","resolve","reject","onloadend","result","onerror","readAsDataURL","_NineSliceGeometry","PlaneGeometry","arguments","length","undefined","defaultOptions","width","height","verticesX","verticesY","_options$width","_options$height","_options$originalWidt","_options$originalHeig","_options$leftWidth","_options$rightWidth","_options$topHeight","_options$bottomHeight","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","updateUvs","updatePositions","positions","w","scaleW","h","scaleH","scale","Math","min","getBuffer","uvs","_uvw","_uvh","QuadGeometry","MeshGeometry","Float32Array","indices","Uint32Array","FilterPipe","push","filterEffect","container","instructionSet","break","renderPipeId","canBundle","action","pop","_filterEffect","_container","execute","instruction","filter","bitmapFontTextParser","test","data","startsWith","parse","txt","_rawData$distanceFiel","items","match","rawData","info","common","page","char","chars","kerning","kernings","distanceField","attributeList","itemData","i2","split","key","strValue","replace","floatValue","parseFloat","value","isNaN","font","pages","lineHeight","fontSize","fontFamily","baseLineOffset","range","parseInt","distanceRange","fieldType","size","face","id","file","map","base","_ref","_charNode$letter","charNode","letter","String","fromCharCode","x","y","xOffset","xoffset","yOffset","yoffset","xAdvance","xadvance","first","second","amount","tilingBit","vertex","header","main","fragment","tilingBitGl","extensions","HTMLTextSystem","HTMLTextPipe","ResizePlugin","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","window","innerWidth","innerHeight","clientWidth","clientHeight","resizeTo","MeshPipe","adaptor","localUniforms","UniformGroup","uTransformMatrix","Matrix","uColor","uRound","localUniformsBindGroup","BindGroup","0","_meshDataHash","_gpuBatchableMeshHash","_adaptor","init","meshData","_getMeshData","wasBatched","batched","isBatched","_geometry","indexSize","vertexSize","_getBatchableMesh","gpuBatchableMesh","gpuMesh","isRenderable","state","blendMode","groupBlendMode","uniforms","groupTransform","color32BitToUniform","groupColorAlpha","_initMeshData","_mesh$_geometry$indic","_mesh$_geometry$posit","_initBatchableMesh","getCanvasFillStyle","fillStyle","context","Texture","WHITE","fill","Color","setValue","color","toHex","pattern","createPattern","source","resource","tempMatrix","matrix","copyTo","frame","setTransform","FillPattern","fillPattern","transform","FillGradient","fillGradient","gradient","createLinearGradient","x0","y0","x1","y1","gradientStops","forEach","addColorStop","offset","warn","FilterSystem","_gpuText","htmlText","gpuText","_getGpuText","newKey","_getKey","textureNeedsUploading","currentKey","_didTextUpdate","_updateText","_destroyRenderableById","htmlTextUid","decreaseReferenceCount","_updateGpuText","catch","e","console","error","padding","_style","updateQuadBounds","bounds","_anchor","_htmlText$resolution","generatingTexture","resolution","getManagedTexture","text","onViewUpdate","initGpuText","gpuTextData","EMPTY","BatchableSprite","renderable","minX","maxX","minY","maxY","SdfShader","Shader","uDistance","gpuProgram","compileHighShaderGpuProgram","bits","colorBit","generateTextureBatchBit","MAX_TEXTURES","localUniformMSDFBit","mSDFBit","roundPixelsBit","glProgram","compileHighShaderGlProgram","colorBitGl","generateTextureBatchBitGl","localUniformMSDFBitGl","mSDFBitGl","roundPixelsBitGl","resources","batchSamplers","batchSamplersUniformGroup","bitmapFontXMLStringParser","includes","bitmapFontXMLParser","parseXML","isSafari","userAgent","getNavigator","xml","getElementsByTagName","getAttribute","_charNode$getAttribut","CanvasPoolClass","canvasOptions","_canvasPool","enableFullScreen","_createCanvasAndContext","pixelWidth","pixelHeight","canvas","createCanvas","getContext","getOptimalCanvasAndContext","minWidth","minHeight","ceil","nextPow2","canvasAndContext","returnCanvasAndContext","clear","CanvasPool","applyMatrix","array","stride","index","a","b","c","d","tx","ty","_MeshGeometry","Geometry","deprecation","v8_0_0","shrinkToFit","shrinkBuffersToFit","positionBuffer","Buffer","label","usage","BufferUsage","VERTEX","COPY_DST","uvBuffer","indexBuffer","INDEX","attributes","aPosition","buffer","format","aUV","topology","batchMode","BitmapTextPipe","loadBitmapFont","bitmapFontCachePlugin","_activeTextures","_createCanvas","RendererType","WEBGPU","getTexture","_buildTexturePromise","style","textKey","_increaseReferenceCount","promise","then","usageCount","htmlTextData","HTMLTextRenderData","fontFamilies","extractFontFamilies","fontCSS","getFontCss","HTMLTextStyle","defaultTextStyle","measured","measureHtmlText","max","image","svgURL","getSVGUrl","loadSVGImage","getTemporaryCanvasFromImage","getPo2TextureFromSource","initSource","activeTexture","_cleanUp","TexturePool","returnTexture","uploadMethodId","getReferenceCount","WebGLSystem","WebGPUSystem","CanvasSystem","defaultFontOptions","fontStyle","fontWeight","_uvUpdateId","_textureMatrixUpdateId","reset","packIndex","indicesOffset","packAttributes","float32View","uint32View","textureId","wt","textureIdAndRound","transformedUvs","textureMatrix","isSimple","_transformedUvs","_updateID","multiplyUvs","abgr","BitmapFontManagerClass","ALPHA","NUMERIC","ALPHANUMERIC","ASCII","skipKerning","getFont","_dynamicFont$ensureCh","fontFamilyKey","overrideFill","_fill","Cache","has","fnt","DynamicBitmapFont","overrideSize","once","dynamicFont","ensureCharacters","call","getLayout","bitmapFont","getBitmapTextLayout","measureText","install","_options","_ref2","_ref3","_ref4","Error","textStyle","TextStyle","flatChars","resolveCharacters","join","uninstall","cacheKey","BitmapFontManager","GraphicsPipe","GraphicsContextSystem","getFastGlobalBounds","target","_getGlobalBoundsRecursive","isValid","isRenderGroupRoot","renderGroup","localTransform","worldTransform","localDisplayStatus","measurable","manageEffects","effects","localBounds","boundsPool","boundsArea","addRect","viewBounds","addFrame","children","advanced","addBounds","invert","relativeGroupTransform","loadFontCSS","CanvasTextSystem","CanvasTextPipe","_PlaneGeometry","super","build","_this$verticesX","_this$verticesY","_this$width","_this$height","total","verts","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","buffers","setUvs","tilingSprite","anchorX","anchorY","_applyAnchorToTexture","anchor","copyFrom","_tileTransform","delay","async","resolve2","setTimeout","onload","src","encodeURIComponent","crossOrigin","TilingSpritePipe","sharedQuad","_tilingSpriteDataHash","tilingSpriteData","_getTilingSpriteData","couldBatch","canBatch","_updateCanBatch","_didTilingSpriteUpdate","_updateBatchableMesh","shader","TilingSpriteShader","groups","globalUniforms","bindGroup","encoder","draw","State","default2d","updateUniforms","_tilingSpriteData$sha","_initTilingSpriteData","slice","renderableData","addressMode","setPositions","_nonPowOf2wrapping","WEBGL","supports","nonPowOf2wrapping","isPowerOfTwo","textStyleToCSS","stroke","_stroke","cssStyleString","fontVariant","letterSpacing","align","whiteSpace","wordWrap","breakWords","wordWrapWidth","strokeToCSS","dropShadow","dropShadowToCSS","cssOverrides","cssStyles","tagStyleToCSS","tagStyles","dropShadowStyle","setAlpha","alpha","toHexa","round","cos","angle","distance","sin","position","blur","templates","out","tagStyle","cssTagStyle","j","FontStylePromiseCache","Map","fontPromises","all","tempBounds","Bounds","getOptimalTexture","alphaMode","emit","end","domElement","styleElement","svgRoot","innerHTML","cssStyle","setAttribute","textContent","toString","XMLSerializer","serializeToString","_gpuProgram","_glProgram","localUniformBit","localUniformBitGl","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","uTexture","uSampler","textureWidth","textureHeight","mapCoord","_text$resolution","canvasText","getTextureSize","textUid","AbstractBitmapFont","EventEmitter","fontMetrics","ascent","descent","baseMeasurementFontSize","baseRenderedFontSize","destroyTextures","removeAllListeners","BitmapFont","_data$distanceField","textures","keys","pageData","_charData$kerning","charData","textureFrame","textureSource","frameReal","Rectangle","codePointAt","CanvasTextMetrics","_textKey","createTextureAndCanvas","_options$resolution","renderTextToCanvas","trim","trimmed","getCanvasBoundingBox","_style$_stroke","fontStringFromTextStyle","lines","lineWidths","maxLineWidth","fontProperties","resetTransform","clearRect","strokeStyle","lineWidth","miterLimit","lineJoin","lineCap","cap","linePositionX","linePositionY","passesCount","_style$_stroke$width","_style$_stroke3","isShadowPass","dsOffsetText","dsOffsetShadow","shadowOptions","dropShadowColor","dropShadowAlpha","shadowColor","toRgbaString","dropShadowBlur","dropShadowDistance","shadowBlur","shadowOffsetX","shadowOffsetY","_style$_fill$alpha","_style$_fill","_style$_stroke2","globalAlpha","linePositionYShift","strokeWidth","_style$_stroke4","_drawLetterSpacing","isStroke","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","textLetterSpacing","strokeText","fillText","currentPosition","stringArray","graphemeSegmenter","previousWidth","currentWidth","currentChar","textStr","item","Array","isArray","startCode","charCodeAt","endCode","j2","from","_gpuBitmapText","bitmapText","graphicsRenderable","_getGpuBitmapText","_updateContext","graphics","syncWithProxy","customShader","_updateDistanceField","_destroyRenderableByUid","renderableUid","proxyGraphics","_sdfShader","currentY","bitmapTextLayout","translate","_x","_y","offsetY","tint","line","charPositions","proxyRenderable","Graphics","_bitmapText$resolutio","dx","sqrt","dy","worldScale","abs","fontScale","_this$_sdfShader","proxy","groupColor","globalDisplayStatus","groupAlpha","_this$cssOverrides","_options$tagStyles","_cssOverrides","_generateKey","_styleKey","generateTextStyleKey","_cssStyle","clone","addOverride","_len","_key","toAdd","v","removeOverride","_len2","_key2","toRemove","for2d","_graphicsBatchesHash","gpuContext","graphicsContext","updateGpuContext","isBatchable","_didGraphicsUpdate","_rebuild","_addToBatcher","batches","_removeBatchForRenderable","contextSystem","getGpuContext","_initBatchesForRenderable","batchPipe","_getBatchesForRenderable","batchClone","BatchableGraphics","graphicsUid","tempHTMLTextRenderData","fontStyleCSS","htmlTextRenderData","document","body","appendChild","contentBounds","getBoundingClientRect","descenderPadding","measureFont","validExtensions","CacheParser","asset","getCacheableAssets","LoadParser","priority","LoaderParserPriority","Normal","path","extname","toLowerCase","loader","bitmapFontData","textureUrls","pageFile","imagePath","dirname","copySearchParams","loadedTextures","load","_resolvedAsset","unload","_sourceOrigin","getGlobalRenderableBounds","renderables","dedupe","regex","matches","addFontFamily","fontFamily2","_dynamicOptions$skipK","_dynamicOptions$resol","_dynamicOptions$paddi","_padding","_measureCache","_currentChars","_currentX","_currentY","_currentPageIndex","_skipKerning","dynamicOptions","requestedFontSize","charList","self","indexOf","_nextPage","currentX","widthScale","maxCharHeight","skipTexture","_style$dropShadow$dis","_style$dropShadow","metrics","paddedWidth","paddedHeight","pageData2","_drawGlyph","px","py","_applyKerning","newChars","measureCache","c1","c2","textureResolution","_setupContext","ImageSource","_stroke$width","textBaseline","strokeThickness","rgb","toArray","_stroke$width2","nssvg","nsxhtml","createElementNS","foreignObject","Image","overflow","quadGeometry","location","_filterStackIndex","_filterStack","_filterGlobalUniforms","uInputSize","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","_this$_activeFilterDa","_activeFilterData","backTexture","filters","_getFilterData","filterData","skip","filterArea","colorTextureSource","renderTarget","rootRenderTarget","colorTexture","_resolution","antialias","blendRequired","enabled","_renderer$backBuffer$","_renderer$backBuffer","isCompatible","compatibleRenderers","backBuffer","useBackBuffer","viewPort","rootViewPort","fitBounds","pad","isPositive","previousRenderSurface","renderSurface","inputTexture","bind","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","apply","flip","flop","t","lastRenderSurface","backgroundResolution","floor","copyToTexture","applyFilter","input","output","Point","isFinalTarget","currentIndex","filterUniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","rootTexture","isRoot","uniformBatch","batchUniforms","getUboResource","_state","calculateSpriteMatrix","outputMatrix","mappedMatrix","prepend","layoutData","spaceWidth","spacesIndex","currentLine","previousChar","firstWord","currentWord","spaceWord","nextWord","word","nextLine","lastChar","adjustedLetterSpacing","adjustedWordWrapWidth","isEnd","isSpace","isWordBreak","addWordToNextLine","nextCharWidth","alignCenter","alignRight","alignJustify","measurementData","indy","spaceIndex","totalSpaces","newSpaceWidth","sampleValues","Int32Array","uTextures","isStatic","checkRow","checkColumn","top","bottom","willReadFrequently","TypeError","imageData","getImageData","left","right","drawImage"],"mappings":"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","file":"js/chunk-e9d966a6.0f1cfcd7.js","sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link app.TickerPluginOptions}.\n * @memberof app\n * @property {boolean} [autoStart=true] - Automatically starts the rendering after the construction.\n * **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n * `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n * @property {boolean} [sharedTicker=false] - Set`true` to use `Ticker.shared`, `false` to create new ticker.\n * If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n * The system ticker will always run before both the shared ticker and the app ticker.\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Automatically starts the rendering after the construction.\n     *  **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n     *  `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n     * @memberof app.ApplicationOptions\n     * @default true\n     */\n    autoStart?: boolean;\n    /**\n     * Set`true` to use `Ticker.shared`, `false` to create new ticker.\n     *  If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n     *  The system ticker will always run before both the shared ticker and the app ticker.\n     * @memberof app.ApplicationOptions\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link ticker.Ticker} functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#start}\n * * {@link app.Application#stop}\n * * {@link app.Application#ticker}\n * @example\n * import { extensions, TickerPlugin } from 'pixi.js';\n *\n * extensions.add(TickerPlugin);\n * @memberof app\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static start: () => void;\n    public static stop: () => void;\n    private static _ticker: Ticker;\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        /**\n         * Convenience method for stopping the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        /**\n         * Convenience method for starting the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        /**\n         * Internal reference to the ticker.\n         * @type {Ticker}\n         * @name _ticker\n         * @memberof app.Application#\n         * @private\n         */\n        this._ticker = null;\n\n        /**\n         * Ticker for doing render updates.\n         * @type {ticker.Ticker}\n         * @name ticker\n         * @memberof app.Application#\n         * @default Ticker.shared\n         */\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _gpuSpriteHash: Record<number, BatchableMesh> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: NineSliceSprite, _instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite.batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const texture = sprite._texture;\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (gpuSprite.texture._source !== texture._source)\n        {\n            return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n        }\n\n        return false;\n    }\n\n    public destroyRenderable(sprite: NineSliceSprite)\n    {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableSprite as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        sprite._didSpriteUpdate = false;\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        const batchableMesh = new BatchableMesh();\n\n        batchableMesh.geometry = new NineSliceGeometry();\n\n        batchableMesh.mesh = sprite;\n\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(sprite);\n        });\n\n        return batchableMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            const batchableMesh = this._gpuSpriteHash[i];\n\n            batchableMesh.geometry.destroy();\n        }\n\n        (this._gpuSpriteHash as null) = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @memberof scene\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @memberof scene\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    public _leftWidth: number;\n    public _rightWidth: number;\n    public _topHeight: number;\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const positions = this.positions;\n\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this.width > w ? 1.0 : this.width / w;\n\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this.height > h ? 1.0 : this.height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n        positions[17] = positions[19] = positions[21] = positions[23] = this.height - (this._bottomHeight * scale);\n        positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n\n        positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n        positions[4] = positions[12] = positions[20] = positions[28] = this.width - (this._rightWidth * scale);\n        positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n// eslint-disable-next-line max-len\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface BitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string, base: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string\n        page: string\n        xoffset: string\n        yoffset: string\n        xadvance: string,\n        x: string\n        y: string\n        width: string\n        height: string\n        letter?: string\n        char?: string\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: 'sdf' | 'msdf' | 'none';\n        distanceRange: string;\n    }[]\n}\n\nexport const bitmapFontTextParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    },\n\n    parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: BitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontRawData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n\n        if (distanceField)\n        {\n            font.distanceField = {\n                range: parseInt(distanceField.distanceRange, 10),\n                type: distanceField.fieldType\n            };\n        }\n\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n\n        const page = rawData.page;\n\n        for (let i = 0; i < page.length; i++)\n        {\n            font.pages.push({\n                id: parseInt(page[i].id, 10) || 0,\n                file: page[i].file,\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n\n        const char = rawData.char;\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            font.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        const kerning = rawData.kerning || [];\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n\n        return font;\n    }\n};\n","export const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n\n};\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link app.ResizePlugin}.\n * @memberof app\n * @property {Window|HTMLElement} [resizeTo=window] - Element to automatically resize the renderer to.\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @memberof app.ApplicationOptions\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#resizeTo}\n * * {@link app.Application#resize}\n * * {@link app.Application#queueResize}\n * * {@link app.Application#cancelResize}\n * @example\n * import { extensions, ResizePlugin } from 'pixi.js';\n *\n * extensions.add(ResizePlugin);\n * @memberof app\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static resizeTo: Window | HTMLElement;\n    public static resize: () => void;\n    public static renderer: ResizeableRenderer;\n    public static queueResize: () => void;\n    public static render: () => void;\n    private static _resizeId: number;\n    private static _resizeTo: Window | HTMLElement;\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            /**\n             * The HTML element or window to automatically resize the\n             * renderer's view element to match width and height.\n             * @member {Window|HTMLElement}\n             * @name resizeTo\n             * @memberof app.Application#\n             */\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        /**\n         * Resize is throttled, so it's safe to call this multiple times per frame and it'll\n         * only be called once.\n         * @memberof app.Application#\n         * @method queueResize\n         * @private\n         */\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        /**\n         * Cancel the resize queue.\n         * @memberof app.Application#\n         * @method cancelResize\n         * @private\n         */\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        /**\n         * Execute an immediate resize on the renderer, this is not\n         * throttled and can be expensive to call many times in a row.\n         * Will resize only if `resizeTo` property is set.\n         * @memberof app.Application#\n         * @method resize\n         */\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\nexport interface MeshInstruction extends Instruction\n{\n    renderPipeId: 'mesh';\n    mesh: Mesh;\n}\n\n// eslint-disable-next-line max-len\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<MeshInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            const texture = mesh.texture;\n\n            if (batchableMesh.texture._source !== texture._source)\n            {\n                if (batchableMesh.texture._source !== texture._source)\n                {\n                    return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add({\n                renderPipeId: 'mesh',\n                mesh\n            } as MeshInstruction);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        if (gpuMesh)\n        {\n            BigPool.return(gpuMesh as PoolItem);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n    }\n\n    public execute({ mesh }: MeshInstruction)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = mesh.groupBlendMode;\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', () =>\n        {\n            this.destroyRenderable(mesh);\n        });\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.mesh = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        gpuMesh.mesh = mesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/GraphicsContext';\n\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D): string | CanvasGradient | CanvasPattern\n{\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).toHex();\n    }\n    else if (!fillStyle.fill)\n    {\n        // fancy set up...\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n\n        // create an inverted scale matrix..\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill as FillPattern;\n\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.frame.width,\n            fillPattern.texture.frame.height\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill as FillGradient;\n\n        if (fillGradient.type === 'linear')\n        {\n            const gradient = context.createLinearGradient(\n                fillGradient.x0,\n                fillGradient.y0,\n                fillGradient.x1,\n                fillGradient.y1\n            );\n\n            fillGradient.gradientStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n\n            return gradient;\n        }\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\nimport type { HTMLTextStyle } from './HtmlTextStyle';\n\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        textureNeedsUploading: boolean;\n        generatingTexture: boolean;\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText._getKey();\n\n        if (gpuText.textureNeedsUploading)\n        {\n            gpuText.textureNeedsUploading = false;\n\n            return true;\n        }\n\n        if (gpuText.currentKey !== newKey)\n        {\n            // TODO - could look into optimising this a tad!\n            // if its a single texture, then we could just swap it?\n            // same for CanvasText..\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(htmlText: HTMLText)\n    {\n        this._destroyRenderableById(htmlText.uid);\n    }\n\n    private _destroyRenderableById(htmlTextUid: number)\n    {\n        const gpuText = this._gpuText[htmlTextUid];\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[htmlTextUid] = null;\n    }\n\n    private _updateText(htmlText: HTMLText)\n    {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n        }\n\n        htmlText._didTextUpdate = false;\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const gpuText = this._getGpuText(htmlText);\n\n        if (gpuText.generatingTexture) return;\n\n        const newKey = htmlText._getKey();\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        gpuText.generatingTexture = true;\n\n        gpuText.currentKey = newKey;\n\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n\n        const texture = await this._renderer.htmlText.getManagedTexture(\n            htmlText.text,\n            resolution,\n            htmlText._style as HTMLTextStyle,\n            htmlText._getKey()\n        );\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        batchableSprite.texture = gpuText.texture = texture;\n\n        gpuText.generatingTexture = false;\n\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const gpuTextData: HTMLTextPipe['_gpuText'][number] = {\n            texture: Texture.EMPTY,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n            textureNeedsUploading: false,\n            generatingTexture: false,\n        };\n\n        const batchableSprite = gpuTextData.batchableSprite;\n\n        batchableSprite.renderable = htmlText;\n        batchableSprite.texture = Texture.EMPTY;\n        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableSprite.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        this._gpuText[htmlText.uid] = gpuTextData;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        htmlText.on('destroyed', () =>\n        {\n            this.destroyRenderable(htmlText);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { MAX_TEXTURES } from '../../../rendering/batcher/shared/const';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { batchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/batchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nexport class SdfShader extends Shader\n{\n    constructor()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(MAX_TEXTURES),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        const glProgram = compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(MAX_TEXTURES),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: batchSamplersUniformGroup,\n            }\n        });\n    }\n}\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser';\n\nimport type { BitmapFontData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLStringParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        if (typeof data === 'string' && data.includes('<font>'))\n        {\n            return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n        }\n\n        return false;\n    },\n\n    parse(data: string): BitmapFontData\n    {\n        return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n    }\n};\n","import { DOMAdapter } from '../../environment/adapter';\n\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        const xml = data as Document;\n\n        return typeof xml !== 'string'\n            && 'getElementsByTagName' in xml\n            && xml.getElementsByTagName('page').length\n            && xml.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    },\n\n    parse(xml: Document): BitmapFontData\n    {\n        const data: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n        const distanceField = xml.getElementsByTagName('distanceField')[0];\n\n        if (distanceField)\n        {\n            data.distanceField = {\n                type: distanceField.getAttribute('fieldType') as 'sdf' | 'msdf' | 'none',\n                range: parseInt(distanceField.getAttribute('distanceRange'), 10),\n            };\n        }\n\n        // pages and chars:\n        const page = xml.getElementsByTagName('page');\n        const char = xml.getElementsByTagName('char');\n        const kerning = xml.getElementsByTagName('kerning');\n\n        data.fontSize = parseInt(info.getAttribute('size'), 10);\n        data.fontFamily = info.getAttribute('face');\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n\n        for (let i = 0; i < page.length; i++)\n        {\n            data.pages.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute('base'), 10);\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.getAttribute('id'), 10);\n\n            let letter = charNode.getAttribute('letter') ?? charNode.getAttribute('char') ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            data.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.getAttribute('page'), 10) || 0,\n                x: parseInt(charNode.getAttribute('x'), 10),\n                y: parseInt(charNode.getAttribute('y'), 10),\n                width: parseInt(charNode.getAttribute('width'), 10),\n                height: parseInt(charNode.getAttribute('height'), 10),\n\n                // render deets..\n                xOffset: parseInt(charNode.getAttribute('xoffset'), 10),\n                yOffset: parseInt(charNode.getAttribute('yoffset'), 10), // + baseLineOffset,\n                xAdvance: parseInt(charNode.getAttribute('xadvance'), 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].getAttribute('first'), 10);\n            const second = parseInt(kerning[i].getAttribute('second'), 10);\n            const amount = parseInt(kerning[i].getAttribute('amount'), 10);\n\n            data.chars[map[second]].kerning[map[first]] = amount;// * 10000;\n        }\n\n        return data;\n    }\n};\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\nexport interface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in\n * @name CanvasPool\n * @memberof rendering\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const { width, height } = canvasAndContext.canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\nexport const CanvasPool = new CanvasPoolClass();\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @memberof scene\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @memberof scene\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {scene.MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { bitmapFontCachePlugin, loadBitmapFont } from './asset/loadBitmapFont';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe, loadBitmapFont, bitmapFontCachePlugin);\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HtmlTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\nimport type { FontCSSStyleOptions } from './utils/loadFontCSS';\n\ninterface HTMLTextTexture\n{\n    texture: Texture,\n    usageCount: number,\n    promise: Promise<Texture>,\n}\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @memberof rendering\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    public static defaultFontOptions: FontCSSStyleOptions = {\n        fontFamily: 'Arial',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n    };\n\n    private _activeTextures: Record<string, HTMLTextTexture> = {};\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(\n            options.text as string,\n            options.resolution,\n            options.style as HTMLTextStyle\n        );\n    }\n\n    public getManagedTexture(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n        textKey: string\n    ): Promise<Texture>\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text, resolution, style)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    private async _buildTexturePromise(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n    )\n    {\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        image.width = width | 0;\n        image.height = height | 0;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        let resource: HTMLImageElement | HTMLCanvasElement = image;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            resource = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(resource, image.width, image.height, resolution);\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        // TODO SHOULD NOT BE NEEDED\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    private _cleanUp(activeTexture: HTMLTextTexture)\n    {\n        TexturePool.returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = 'unknown';\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import type { Batch, BatchableObject, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Container } from '../../container/Container';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements BatchableObject\n{\n    public indexStart: number;\n    public textureId: number;\n    public texture: Texture;\n    public location: number;\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public mesh: Container;\n    public geometry: MeshGeometry;\n\n    public roundPixels: 0 | 1 = 0;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n    private _textureMatrixUpdateId: number = -1;\n\n    get blendMode() { return this.mesh.groupBlendMode; }\n\n    public reset()\n    {\n        this.mesh = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = this.geometry.indices;\n\n        for (let i = 0; i < indices.length; i++)\n        {\n            indexBuffer[index++] = indices[i] + indicesOffset;\n        }\n    }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const mesh = this.mesh;\n\n        const geometry = this.geometry;\n        const wt = mesh.groupTransform;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        // const trim = texture.trim;\n        const positions = geometry.positions;\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        const abgr = mesh.groupColorAlpha;\n\n        for (let i = 0; i < positions.length; i += 2)\n        {\n            const x = positions[i];\n            const y = positions[i + 1];\n\n            float32View[index] = (a * x) + (c * y) + tx;\n            float32View[index + 1] = (b * x) + (d * y) + ty;\n\n            // TODO implement texture matrix?\n            float32View[index + 2] = transformedUvs[i];\n            float32View[index + 3] = transformedUvs[i + 1];\n\n            uint32View[index + 4] = abgr;\n            uint32View[index + 5] = textureIdAndRound;\n\n            index += 6;\n        }\n    }\n\n    get vertexSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","export const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `,\n    }\n\n};\n\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `,\n    }\n\n};\n","import { Cache } from '../../assets/cache/Cache';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\n/**\n *\n * The options for installing a new BitmapFont. Once installed the font will be available for use in the BitmapText.\n * It can be accessed by the `fontFamily` property of the TextStyle.\n *\n * Install a new BitmapFont will create the characters provided for the font and store them in the cache.\n * But don't worry, if a character is requested that hasn't been generated yet, it will be created on the fly.\n * @memberof text\n */\nexport interface BitmapFontInstallOptions\n{\n    /** the name of the font, this will be the name you use in the fontFamily of text style to access this font */\n    name?: string;\n    /**\n     * Characters included in the font set. You can also use ranges.\n     * For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     */\n    chars?: string | (string | string[])[];\n    /**\n     * Render resolution for glyphs.\n     * @default 1\n     */\n    resolution?: number;\n    /**\n     * Padding between glyphs on texture atlas. Lower values could mean more visual artifacts\n     * and bleeding from other glyphs, larger values increase the space required on the texture.\n     * @default 4\n     */\n    padding?: number;\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * If true, this could potentially increase the performance, but may impact the rendered text appearance.\n     * @default false\n     */\n    skipKerning?: boolean;\n    /** Style options to render with BitmapFont. */\n    style?: TextStyle | TextStyleOptions;\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @memberof text\n * @name BitmapFontManager\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n    };\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill)\n        {\n            fontFamilyKey += style._fill.fill.uid;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const fnt = new DynamicBitmapFont({\n                style,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fnt.once('destroy', () => Cache.remove(fontFamilyKey));\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     */\n    public getLayout(text: string, style: TextStyle): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        return getBitmapTextLayout(text.split(''), style, bitmapFont);\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     */\n    public measureText(text: string, style: TextStyle): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== undefined;\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            Cache.remove(cacheKey);\n            font.destroy();\n        }\n    }\n}\n\nexport const BitmapFontManager = new BitmapFontManagerClass();\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n// TODO could we cache local bounds on the render groups?\n\nconst tempMatrix = new Matrix();\n\n/**\n * Does exactly the same as getGlobalBounds, but does instead makes use of transforming AABBs\n * of the various children within the scene graph. This is much faster, but less accurate.\n *\n * the result will never be smaller - only ever slightly larger (in most cases, it will be the same).\n * @param target - The target container to get the bounds from\n * @param bounds - The output bounds object.\n * @returns The bounds.\n */\nexport function getFastGlobalBounds(target: Container, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    _getGlobalBoundsRecursive(target, bounds);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    if (!target.isRenderGroupRoot)\n    {\n        bounds.applyMatrix(target.renderGroup.worldTransform);\n    }\n    else\n    {\n        bounds.applyMatrix(target.renderGroup.localTransform);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBoundsRecursive(\n    target: Container,\n    bounds: Bounds,\n)\n{\n    if (target.localDisplayStatus !== 0b111 || !target.measurable)\n    {\n        return;\n    }\n\n    const manageEffects = !!target.effects.length;\n\n    let localBounds = bounds;\n\n    if (target.isRenderGroupRoot || manageEffects)\n    {\n        localBounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, target.worldTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            const viewBounds = (target as Renderable).bounds;\n\n            localBounds.addFrame(\n                viewBounds.minX,\n                viewBounds.minY,\n                viewBounds.maxX,\n                viewBounds.maxY,\n                target.groupTransform\n            );\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getGlobalBoundsRecursive(children[i], localBounds);\n        }\n    }\n\n    if (manageEffects)\n    {\n        let advanced = false;\n\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            if (target.effects[i].addBounds)\n            {\n                if (!advanced)\n                {\n                    advanced = true;\n                    localBounds.applyMatrix(target.renderGroup.worldTransform);\n                }\n\n                target.effects[i].addBounds(localBounds, true);\n            }\n        }\n\n        if (advanced)\n        {\n            localBounds.applyMatrix(target.renderGroup.worldTransform.copyTo(tempMatrix).invert());\n            bounds.addBounds(localBounds, target.relativeGroupTransform);\n        }\n\n        bounds.addBounds(localBounds);\n        boundsPool.return(localBounds);\n    }\n    else if (target.isRenderGroupRoot)\n    {\n        bounds.addBounds(localBounds, target.relativeGroupTransform);\n        boundsPool.return(localBounds);\n    }\n}\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\nexport interface FontCSSStyleOptions\n{\n    fontFamily: string | string[]\n    fontWeight: string\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link scene.PlaneGeometry}\n * @memberof scene\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @memberof scene\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite._applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\ninterface RenderableData\n{\n    canBatch: boolean;\n    renderable: TilingSprite\n    batchableMesh?: BatchableMesh;\n    geometry?: MeshGeometry;\n    shader?: TilingSpriteShader;\n}\n\nconst sharedQuad = new QuadGeometry();\n\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private readonly _tilingSpriteDataHash: Record<number, RenderableData> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            // we are batching.. check a texture change!\n            if (batchableMesh.texture._source !== renderable.texture._source)\n\n            { return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture); }\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite._didTilingSpriteUpdate)\n            {\n                tilingSprite._didTilingSpriteUpdate = false;\n\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.mesh = tilingSprite;\n                batchableMesh.texture = tilingSprite._texture;\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: State.default2d,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite._didTilingSpriteUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh.batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite._didTilingSpriteUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n\n        tilingSprite._didTilingSpriteUpdate = false;\n    }\n\n    public destroyRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        tilingSpriteData.batchableMesh = null;\n\n        tilingSpriteData.shader?.destroy();\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): RenderableData\n    {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): RenderableData\n    {\n        const geometry = new MeshGeometry({\n            indices: sharedQuad.indices,\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry,\n        };\n\n        tilingSprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(tilingSprite);\n        });\n\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        for (const i in this._tilingSpriteDataHash)\n        {\n            this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        }\n\n        (this._tilingSpriteDataHash as null) = null;\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Color } from '../../../color/Color';\n\nimport type { StrokeStyle } from '../../graphics/shared/GraphicsContext';\nimport type { TextStyle } from '../../text/TextStyle';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../HtmlTextStyle';\n\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string\n{\n    const stroke = style._stroke;\n    const fill = style._fill;\n\n    const cssStyleString = [\n        `color: ${Color.shared.setValue(fill.color).toHex()}`,\n        `font-size: ${(style.fontSize as number)}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${(style.whiteSpace === 'pre' && style.wordWrap) ? 'pre-wrap' : style.whiteSpace}`,\n        ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? 'break-all' : 'break-word'}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [strokeToCSS(stroke)] : [],\n        ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n        ...style.cssOverrides,\n    ].join(';');\n\n    const cssStyles = [`div { ${cssStyleString} }`];\n\n    tagStyleToCSS(style.tagStyles, cssStyles);\n\n    return cssStyles.join(' ');\n}\n\nfunction dropShadowToCSS(dropShadowStyle: TextStyle['dropShadow']): string\n{\n    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n\n    const position = `${x}px ${y}px`;\n\n    if (dropShadowStyle.blur > 0)\n    {\n        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    }\n\n    return `text-shadow: ${position} ${color}`;\n}\n\nfunction strokeToCSS(stroke: StrokeStyle): string\n{\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        'paint-order: stroke',\n    ].join(';');\n}\n\n/** Converts the tag styles into CSS. */\nconst templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`,\n};\n\n/** Converts the tag styles into CSS if modifications are required */\nconst transform = {\n    fill: (value: string) => `color: ${Color.shared.setValue(value).toHex()}`,\n    breakWords: (value: string) => `word-wrap: ${value ? 'break-all' : 'break-word'}`,\n    stroke: strokeToCSS,\n    dropShadow: dropShadowToCSS\n};\n\nfunction tagStyleToCSS(tagStyles: Record<string, HTMLTextStyleOptions>, out: string[])\n{\n    for (const i in tagStyles)\n    {\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n\n        for (const j in tagStyle)\n        {\n            if (transform[j as keyof typeof transform])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(transform[j as keyof typeof transform](tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n            else if (templates[j as keyof typeof templates])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(templates[j as keyof typeof templates].replace('{{VALUE}}', tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n        }\n\n        out.push(`${i} { ${cssTagStyle.join(';')} }`);\n    }\n}\n","import { Cache } from '../../../assets/cache/Cache';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { FontCSSStyleOptions } from './loadFontCSS';\n\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The FontCSSStyleOptions to load the font with (used for the first font family)\n * @param defaultOptions - The default options to load the font with (used for the rest of the font families)\n * @param defaultOptions.fontWeight - The default font weight\n * @param defaultOptions.fontStyle - The default font style\n * @returns - The css string\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n    style: FontCSSStyleOptions,\n    defaultOptions: {fontWeight: string, fontStyle: string}\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(`${fontFamily}-and-url`);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: defaultOptions.fontWeight,\n                        fontStyle: defaultOptions.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n\n    }\n};\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text._getKey();\n\n        if (gpuText.currentKey !== newKey)\n        {\n            const resolution = text.resolution ?? this._renderer.resolution;\n\n            const { width, height } = this._renderer.canvasText.getTextureSize(\n                text.text,\n                resolution,\n                text._style,\n            );\n\n            if (\n                // is only being used by this text:\n                this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1\n                // check the size of the text is the same po2\n                && width === gpuText.texture._source.width\n                && height === gpuText.texture._source.height\n            )\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(text: Text, _instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(text);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(text: Text)\n    {\n        this._destroyRenderableById(text.uid);\n    }\n\n    private _destroyRenderableById(textUid: number)\n    {\n        const gpuText = this._gpuText[textUid];\n\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[textUid] = null;\n    }\n\n    private _updateText(text: Text)\n    {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(text);\n        }\n\n        text._didTextUpdate = false;\n\n        const padding = text._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        }\n\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);\n\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const gpuTextData: CanvasTextPipe['_gpuText'][number] = {\n            texture: null,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n        };\n\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        gpuTextData.batchableSprite.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        this._gpuText[text.uid] = gpuTextData;\n\n        this._updateText(text);\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        text.on('destroyed', () =>\n        {\n            this.destroyRenderable(text);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @memberof text */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @memberof text\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @memberof text\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @memberof text\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            this.chars[i].texture.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n","import { Rectangle } from '../../maths/shapes/Rectangle';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { BitmapFontManager } from './BitmapFontManager';\n\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { BitmapFontData } from './AbstractBitmapFont';\nimport type { BitmapFontInstallOptions } from './BitmapFontManager';\n\n/**\n * Options for creating a BitmapFont.\n * @memberof text\n */\nexport interface BitmapFontOptions\n{\n    data: BitmapFontData\n    textures: Texture[]\n}\n\n/**\n * A BitmapFont object represents a particular font face, size, and style.\n * @memberof text\n */\nexport class BitmapFont extends AbstractBitmapFont<BitmapFont>\n{\n    /** the url of the font */\n    public url?: string;\n\n    constructor(options: BitmapFontOptions, url?: string)\n    {\n        super();\n\n        const { textures, data } = options;\n\n        Object.keys(data.pages).forEach((key: string) =>\n        {\n            const pageData = data.pages[parseInt(key, 10)];\n\n            const texture = textures[pageData.id];\n\n            this.pages.push({ texture });\n        });\n\n        Object.keys(data.chars).forEach((key: string) =>\n        {\n            const charData = data.chars[key];\n            const {\n                frame: textureFrame,\n                source: textureSource,\n            } = textures[charData.page];\n\n            const frameReal = new Rectangle(\n                charData.x + textureFrame.x,\n                charData.y + textureFrame.y,\n                charData.width,\n                charData.height,\n            );\n\n            const texture = new Texture({\n                source: textureSource,\n                frame: frameReal\n            });\n\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture,\n            };\n        });\n\n        this.baseRenderedFontSize = data.fontSize;\n\n        (this.baseMeasurementFontSize as number) = data.fontSize;\n        (this.fontMetrics as FontMetrics) = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize,\n        };\n        (this.baseLineOffset as number) = data.baseLineOffset;\n        (this.lineHeight as number) = data.lineHeight;\n        (this.fontFamily as string) = data.fontFamily;\n        (this.distanceField as { type: string, range: number }) = data.distanceField ?? {\n            type: 'none',\n            range: 0,\n        };\n\n        this.url = url;\n    }\n\n    /** Destroys the BitmapFont object. */\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { texture } = this.pages[i];\n\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFont, BitmapText } from 'pixi.js';\n     *\n     * BitmapFont.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public static install(options: BitmapFontInstallOptions)\n    {\n        BitmapFontManager.install(options);\n    }\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public static uninstall(name: string)\n    {\n        BitmapFontManager.uninstall(name);\n    }\n}\n","import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { TextOptions } from '../AbstractText';\nimport type { Text } from '../Text';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    private readonly _renderer: Renderer;\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    public getTexture(options: TextOptions): Texture;\n    public getTexture(options: TextOptions | string, resolution?: number, style?: TextStyle, _textKey?: string): Texture\n    {\n        if (typeof options === 'string')\n        {\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n\n            options = {\n                text: options,\n                style,\n                resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(\n            options as {text: string, style: TextStyle, resolution?: number}\n        );\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    public createTextureAndCanvas(options: {text: string, style: TextStyle, resolution?: number})\n    {\n        const { text, style } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        return { texture, canvasAndContext };\n    }\n\n    public getManagedTexture(text: Text)\n    {\n        const textKey = text._getKey();\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(text);\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n            TexturePool.returnTexture(activeTexture.texture);\n\n            const source = activeTexture.texture.source;\n\n            source.resource = null;\n            source.uploadMethodId = 'unknown';\n            source.alphaMode = 'no-premultiply-alpha';\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n\n        context.scale(resolution, resolution);\n\n        const padding = style.padding * 2;\n\n        context.clearRect(0, 0, measured.width + 4 + padding, measured.height + 4 + padding);\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.globalAlpha = style._fill?.alpha ?? 1;\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n\n                if (style._stroke?.width)\n                {\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\n\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { BitmapText } from './BitmapText';\n\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuBitmapText: Record<number, Graphics> = {};\n    private _sdfShader: SdfShader;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public destroyRenderable(bitmapText: BitmapText)\n    {\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n\n    private _destroyRenderableByUid(renderableUid: number)\n    {\n        BigPool.return(this._gpuBitmapText[renderableUid] as PoolItem);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                if (!this._sdfShader)\n                {\n                    this._sdfShader = new SdfShader();\n                }\n\n                context.customShader = this._sdfShader;\n            }\n        }\n\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = (style._stroke?.width || 0) / 2;\n\n        currentY += bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        context\n            .translate(\n                (-bitmapText._anchor._x * bitmapTextLayout.width) - padding,\n                (-bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY)) - padding)\n            .scale(scale, scale);\n\n        const tint = style._fill.color;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that hav the same style!\n        const proxyRenderable = BigPool.get(Graphics);\n\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        bitmapText.on('destroyed', () =>\n        {\n            this.destroyRenderable(bitmapText);\n        });\n\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const resolution = bitmapText.resolution ?? this._renderer.resolution;\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        for (const uid in this._gpuBitmapText)\n        {\n            this._destroyRenderableByUid(uid as unknown as number);\n        }\n\n        this._gpuBitmapText = null;\n\n        this._sdfShader?.destroy(true);\n        this._sdfShader = null;\n\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import type { TilingSprite } from '../TilingSprite';\n\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","/* eslint-disable accessor-pairs */\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { generateTextStyleKey } from '../text/utils/generateTextStyleKey';\nimport { textStyleToCSS } from './utils/textStyleToCSS';\n\nimport type { FillStyleInputs } from '../graphics/shared/GraphicsContext';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * Options for HTML text style, extends {@link TextStyle}.\n * @memberof text\n * @extends text.TextStyleOptions\n * @property {string[]} [cssOverrides] - CSS style(s) to add.\n * @property {Record<string, text.HTMLTextStyleOptions>} [tagStyles] - Tag styles.\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, 'leading' | 'textBaseline' | 'trim' >\n{\n    cssOverrides?: string[];\n    tagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @memberof text\n */\nexport class HTMLTextStyle extends TextStyle\n{\n    private _cssOverrides: string[] = [];\n    private _cssStyle: string;\n    /**\n     * List of styles per tag.\n     * @example\n     * new HTMLText({\n     *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n     *   style:{\n     *       fontFamily: 'DM Sans',\n     *       fill: 'white',\n     *       fontSize:100,\n     *       tagStyles:{\n     *           red:{\n     *               fill:'red',\n     *           },\n     *           blue:{\n     *               fill:'blue',\n     *           },\n     *           green:{\n     *               fill:'green',\n     *           }\n     *       }\n     *   }\n     * );\n     */\n    public tagStyles: Record<string, HTMLTextStyleOptions>;\n\n    constructor(options: HTMLTextStyleOptions = {})\n    {\n        super(options);\n\n        this.cssOverrides ??= options.cssOverrides;\n        this.tagStyles = options.tagStyles ?? {};\n    }\n\n    /** List of style overrides that will be applied to the HTML text. */\n    set cssOverrides(value: string | string[])\n    {\n        this._cssOverrides = value instanceof Array ? value : [value];\n        this.update();\n    }\n\n    get cssOverrides(): string[]\n    {\n        return this._cssOverrides;\n    }\n\n    protected override _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join('-');\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._cssStyle = null;\n        super.update();\n    }\n\n    /**\n     * Creates a new HTMLTextStyle object with the same values as this one.\n     * @returns New cloned HTMLTextStyle object\n     */\n    public clone(): HTMLTextStyle\n    {\n        return new HTMLTextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n        });\n    }\n\n    get cssStyle(): string\n    {\n        if (!this._cssStyle)\n        {\n            this._cssStyle = textStyleToCSS(this);\n        }\n\n        return this._cssStyle;\n    }\n\n    /**\n     * Add a style override, this can be any CSS property\n     * it will override any built-in style. This is the\n     * property and the value as a string (e.g., `color: red`).\n     * This will override any other internal style.\n     * @param {string} value - CSS style(s) to add.\n     * @example\n     * style.addOverride('background-color: red');\n     */\n    public addOverride(...value: string[]): void\n    {\n        const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n\n        if (toAdd.length > 0)\n        {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove any overrides that match the value.\n     * @param {string} value - CSS style to remove.\n     * @example\n     * style.removeOverride('background-color: red');\n     */\n    public removeOverride(...value: string[]): void\n    {\n        const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n\n        if (toRemove.length > 0)\n        {\n            this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n            this.update();\n        }\n    }\n\n    override set fill(value: FillStyleInputs)\n    {\n        // if its not a string or a number, then its a texture!\n        if (typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color fill is not supported by HTMLText');\n            // #endif\n        }\n\n        super.fill = value;\n    }\n\n    override set stroke(value: FillStyleInputs)\n    {\n        // if its not a string or a number, then its a texture!\n        if (value && typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color stroke is not supported by HTMLText');\n            // #endif\n        }\n\n        super.stroke = value;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    init(): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\nexport interface GraphicsSystem\n{\n    graphicsContext: GraphicsContextSystem;\n    renderPipes: {\n        batch: BatchPipe\n    }\n    _roundPixels: 0 | 1;\n}\n\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: GraphicsSystem;\n    public state: State = State.for2d();\n\n    // batchable graphics list, used to render batches\n    private _graphicsBatchesHash: Record<number, BatchableGraphics[]> = Object.create(null);\n    private _adaptor: GraphicsAdaptor;\n\n    constructor(renderer: GraphicsSystem, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n        this._adaptor.init();\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n\n        const context = graphics.context;\n\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n\n        if (graphics._didGraphicsUpdate)\n        {\n            graphics._didGraphicsUpdate = false;\n\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n\n        if (batches)\n        {\n            for (let i = 0; i < batches.length; i++)\n            {\n                const batch = batches[i];\n\n                batch.batcher.updateElement(batch);\n            }\n        }\n    }\n\n    public destroyRenderable(graphics: Graphics)\n    {\n        if (this._graphicsBatchesHash[graphics.uid])\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // TODO POOL the old batches!\n\n        if (wasBatched)\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._initBatchesForRenderable(graphics);\n        }\n\n        graphics.batched = gpuContext.isBatchable;\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getBatchesForRenderable(graphics);\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n\n    private _initBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        const batches = gpuContext.batches.map((batch) =>\n        {\n            // TODO pool this!!\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n\n        this._graphicsBatchesHash[graphics.uid] = batches;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        graphics.on('destroyed', () =>\n        {\n            this.destroyRenderable(graphics);\n        });\n\n        return batches;\n    }\n\n    private _removeBatchForRenderable(graphicsUid: number)\n    {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n\n        for (const i in this._graphicsBatchesHash)\n        {\n            this._removeBatchForRenderable(i as unknown as number);\n        }\n\n        this._graphicsBatchesHash = null;\n    }\n}\n","import { CanvasTextMetrics } from '../../text/canvas/CanvasTextMetrics';\nimport { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;\n\n    return {\n        width: contentBounds.width,\n        height: contentBounds.height + descenderPadding,\n    };\n}\n","import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { path } from '../../../utils/path';\nimport { BitmapFont } from '../BitmapFont';\nimport { bitmapFontTextParser } from './bitmapFontTextParser';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser';\n\nimport type { Loader } from '../../../assets/loader/Loader';\nimport type { LoaderParser } from '../../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../../assets/types';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst validExtensions = ['.xml', '.fnt'];\n\n/** simple loader plugin for loading in bitmap fonts! */\nexport const bitmapFontCachePlugin = {\n    extension: ExtensionType.CacheParser,\n    test: (asset: BitmapFont) => asset instanceof BitmapFont,\n    getCacheableAssets(keys: string[], asset: BitmapFont)\n    {\n        const out: Record<string, BitmapFont> = {};\n\n        keys.forEach((key) =>\n        {\n            out[key] = asset;\n        });\n\n        out[`${asset.fontFamily}-bitmap`] = asset;\n\n        return out;\n    }\n};\n\nexport const loadBitmapFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Normal,\n    },\n\n    test(url: string): boolean\n    {\n        return validExtensions.includes(path.extname(url).toLowerCase());\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n    },\n\n    async parse(asset: string, data: ResolvedAsset, loader: Loader): Promise<BitmapFont>\n    {\n        const bitmapFontData = bitmapFontTextParser.test(asset)\n            ? bitmapFontTextParser.parse(asset)\n            : bitmapFontXMLStringParser.parse(asset);\n\n        const { src } = data;\n        const { pages } = bitmapFontData;\n        const textureUrls = [];\n\n        for (let i = 0; i < pages.length; ++i)\n        {\n            const pageFile = pages[i].file;\n            let imagePath = path.join(path.dirname(src), pageFile);\n\n            imagePath = copySearchParams(imagePath, src);\n\n            textureUrls.push(imagePath);\n        }\n\n        const loadedTextures = await loader.load<Texture>(textureUrls);\n        const textures = textureUrls.map((url) => loadedTextures[url]);\n\n        const bitmapFont = new BitmapFont({\n            data: bitmapFontData,\n            textures\n        }, src);\n\n        return bitmapFont;\n    },\n\n    async load(url: string, _options: ResolvedAsset): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        return await response.text();\n    },\n\n    async unload(bitmapFont: BitmapFont, _resolvedAsset, loader): Promise<void>\n    {\n        await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n\n        bitmapFont.destroy();\n    }\n} as LoaderParser;\n","import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        renderable.addBounds(bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n","import type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { TextStyle } from '../text/TextStyle';\n\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @memberof text\n * @ignore\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 4;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = options;\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = resolveCharacters(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        const widthScale = style.fontStyle === 'italic' ? 2 : 1;\n        let maxCharHeight = 0;\n        let skipTexture = false;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps heigh\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = (widthScale * metrics.width) * fontScale;\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = width + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));// / 1.5;\n            }\n\n            if (currentX + paddedWidth > 512)\n            {\n                currentY += maxCharHeight;\n\n                // reset the line x and height..\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + maxCharHeight > 512)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentY = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n\n            // now add it to the font data..\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload'\n            }),\n\n        });\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        if (style.stroke && strokeThickness)\n        {\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (style._fill)\n        {\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n","import type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\nexport const nssvg = 'http://www.w3.org/2000/svg';\nexport const nsxhtml = 'http://www.w3.org/1999/xhtml';\n\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            location: 0,\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            getFastGlobalBounds(instruction.container, bounds);\n        }\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = colorTextureSource._resolution;\n\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for any filter, it should be true\n        let antialias = colorTextureSource.antialias;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias !== 'inherit')\n            {\n                if (filter.antialias === 'on')\n                {\n                    antialias = true;\n                }\n                else\n                {\n                    antialias = false;\n                }\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const viewPort = renderer.renderTarget.rootViewPort;\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        // need to factor in resolutions also..\n        bounds.scale(resolution)\n            .fitBounds(0, viewPort.width, 0, viewPort.height)\n            .scale(1 / resolution)\n            .pad(padding)\n            .ceil();\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // eslint-disable-next-line max-len\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n","import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\nexport function getBitmapTextLayout(chars: string[], style: TextStyle, font: AbstractBitmapFont<any>): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n        let lastChar = currentLine.chars[index];\n\n        while (lastChar === ' ')\n        {\n            currentLine.width -= font.chars[lastChar].xAdvance;\n            lastChar = currentLine.chars[--index];\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord\n                && style.wordWrap\n                && (currentLine.width + currentWord.width - adjustedLetterSpacing) > adjustedWordWrapWidth;\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                if (currentLine.width !== 0)\n                {\n                    nextLine();\n                }\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n","import { MAX_TEXTURES } from '../../../batcher/shared/const';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst sampleValues = new Int32Array(MAX_TEXTURES);\n\nfor (let i = 0; i < MAX_TEXTURES; i++)\n{\n    sampleValues[i] = i;\n}\n\nexport const batchSamplersUniformGroup = new UniformGroup({\n    uTextures: { value: sampleValues, type: `i32`, size: MAX_TEXTURES }\n}, { isStatic: true });\n","import { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @param canvas - The canvas to measure.\n * @param resolution - The resolution of the canvas.\n * @returns The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n * @memberof utils\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution = 1): Rectangle\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * This canvas is immediately returned to the CanvasPool for reuse, so use the result straight away!\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): HTMLCanvasElement\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas and context to the CanvasPool.\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n    // Return the canvas.\n    return canvasAndContext.canvas as HTMLCanvasElement;\n}\n\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n"],"sourceRoot":""}